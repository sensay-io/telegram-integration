// This file is auto-generated by @hey-api/openapi-ts

/**
 * The UUID of the Replica
 */
export type ReplicaUuidParameter = string;

/**
 * ID of the knowledge base entry
 */
export type TrainingIdParameter = number | null;

export type TheLinkedAccountsOfTheUser = Array<{
    /**
     * The account ID
     */
    accountID: string;
    /**
     * The account type
     */
    accountType: 'discord' | 'telegram' | 'embed';
}>;

export type PutV1ReplicasByReplicaUuidTrainingByTrainingIdData = {
    body?: {
        /**
         * Raw text of the knowledge base entry
         */
        rawText?: string;
        /**
         * Processed text of the knowledge base entry
         */
        processedText?: string;
        /**
         * ID of the vector entry
         */
        vectorEntryId?: string;
        /**
         * Metadata object to be stored with the vector entry (only used when vectorEntryId is present)
         */
        metadata?: {};
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
        trainingID?: TrainingIdParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/training/{trainingID}';
};

export type PutV1ReplicasByReplicaUuidTrainingByTrainingIdErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Knowledge base entry not found.
     */
    404: {
        success: false;
        message: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type PutV1ReplicasByReplicaUuidTrainingByTrainingIdError = PutV1ReplicasByReplicaUuidTrainingByTrainingIdErrors[keyof PutV1ReplicasByReplicaUuidTrainingByTrainingIdErrors];

export type PutV1ReplicasByReplicaUuidTrainingByTrainingIdResponses = {
    /**
     * Knowledge base entry updated successfully.
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
    };
};

export type PutV1ReplicasByReplicaUuidTrainingByTrainingIdResponse = PutV1ReplicasByReplicaUuidTrainingByTrainingIdResponses[keyof PutV1ReplicasByReplicaUuidTrainingByTrainingIdResponses];

export type GetV1ReplicasData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path?: never;
    query?: {
        /**
         * Filters by the owner UUID of the Replicas
         */
        owner_uuid?: string;
        /**
         * Pagination: The page index to return
         */
        page_index?: number;
        /**
         * Pagination: The number of items per page
         */
        page_size?: number;
        /**
         * Search: by name of Replica, sorted in ascending order
         */
        search?: string;
        /**
         * Filters by tags associated to Replicas
         */
        tags?: Array<'AI' | 'Academic' | 'Arts' | 'Blockchain' | 'Business' | 'Celebrity' | 'Charity' | 'Developer' | 'Educator' | 'Europe' | 'Fashion' | 'Finance' | 'Food' | 'Health & Fitness' | 'History' | 'Italian' | 'Kids' | 'Language' | 'Law' | 'Leadership' | 'Lifestyle' | 'Literature' | 'Love' | 'Military' | 'Modelling' | 'Motivation' | 'Movies' | 'Music' | 'North America' | 'Philosophy' | 'Politics' | 'Religion' | 'Science' | 'Self-Help' | 'Sensay' | 'Sports' | 'Technology' | 'Web' | 'Wisdom' | 'blockchain' | 'engage2earn' | 'female' | 'investment' | 'male' | 'meme' | 'miniapp' | 'telegram' | 'web3'> | string;
        /**
         * Sorts by name or popularity of Replicas in ascending order
         */
        sort?: 'name' | 'popularity';
        /**
         * Filters by integration
         */
        integration?: 'telegram' | 'discord';
    };
    url: '/v1/replicas';
};

export type GetV1ReplicasErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasError = GetV1ReplicasErrors[keyof GetV1ReplicasErrors];

export type GetV1ReplicasResponses = {
    /**
     * List of Replicas
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        type: string;
        /**
         * Array of replica items for the current page. May be absent if no items exist.
         */
        items?: Array<{
            /**
             * The UUID of the Replica
             */
            uuid: string | null;
            /**
             * The Name of the Replica
             */
            name: string | null;
            /**
             * The Slug of the Replica
             */
            slug: string | null;
            /**
             * The URL of the profile image of the Replica
             */
            profile_image: string | null;
            /**
             * The description of the Replica
             */
            short_description: string | null;
            /**
             * The introduction of the Replica
             */
            introduction: string | null;
            /**
             * The Tags associated to the Replica
             */
            tags: Array<string> | null;
            /**
             * The date and time the Replica was created
             */
            created_at: string | null;
            /**
             * The UUID of the owner of the Replica
             */
            owner_uuid: string | null;
            /**
             * Does replica have voice support
             */
            voice_enabled: boolean;
            /**
             * Does replica have video support
             */
            video_enabled: boolean;
            /**
             * The number of completions of the Replica
             */
            chat_history_count: number | null;
            /**
             * The replica's tone, personality and behaviour
             */
            system_message: string;
            /**
             * The Discord integration of the Replica
             */
            discord_integration: {
                token: string | null;
                service_name: string | null;
                is_active: boolean | null;
            } | null;
            /**
             * The Telegram integration of the Replica
             */
            telegram_integration: {
                token: string | null;
                service_name: string | null;
            } | null;
        }>;
        /**
         * The total number of replica items available across all pages
         */
        total: number;
    };
};

export type GetV1ReplicasResponse = GetV1ReplicasResponses[keyof GetV1ReplicasResponses];

export type PostV1ReplicasData = {
    body?: {
        /**
         * The name of the replica.
         */
        name: string;
        /**
         * A short description of your replica's purpose or personality.
         */
        shortDescription: string;
        /**
         * The first thing your replica will say when you start a conversation with them.
         */
        greeting: string;
        /**
         * The replica type.
         * `individual`: A replica of yourself.
         * `character`: A replica of a character: can be anything you want.
         * `brand`: A replica of a business persona or organization.
         */
        type?: 'individual' | 'character' | 'brand';
        /**
         * The replica owner ID.
         */
        ownerID: string;
        /**
         * Visibility of the replica. When set to `true`, only the owner will be able to find the replica and chat with it.
         */
        private?: boolean;
        /**
         * Emails of users who can use the replica.
         */
        whitelistEmails?: Array<string>;
        /**
         * The slug of the replica. Slugs can be used by API consumers to determine the URLs where replicas can be found.
         */
        slug: string;
        /**
         * The tags associated with the replica. Tags help categorize replicas and make them easier to find.
         */
        tags?: Array<string>;
        /**
         * The URL of the profile image of the replica. The image will be downloaded, optimized and stored on our servers, so the URL in the response will be different. Supported formats: .jpg, .jpeg, .png, .bmp, .webp, .avif
         */
        profileImage?: string;
        /**
         * Suggested questions when starting a conversation.
         */
        suggestedQuestions?: Array<string>;
        llm: {
            /**
             * The LLM model of the replica.
             */
            model?: 'gpt-4o' | 'claude-3-5-haiku-latest' | 'claude-3-7-sonnet-latest' | 'grok-2-latest' | 'deepseek-chat' | 'o3-mini' | 'gpt-4o-mini' | 'huggingface-eva' | 'huggingface-dolphin-llama';
            /**
             * The memory mode of the replica.
             */
            memoryMode?: 'prompt-caching' | 'rag-search';
            /**
             * Who is your replica? How do you want it to talk, respond and act.
             */
            systemMessage?: string;
            /**
             * The replica's tools. Tools enable agents to interact with the world.
             */
            tools?: Array<'getTokenInfo' | 'getUdaoTokenInfo' | 'getSensayTokenInfo' | 'getTokenInfoMEAI' | 'answerToLife' | 'toolhouse'>;
        };
    };
    headers?: {
        'X-API-Version'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/replicas';
};

export type PostV1ReplicasErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Conflict
     */
    409: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type PostV1ReplicasError = PostV1ReplicasErrors[keyof PostV1ReplicasErrors];

export type PostV1ReplicasResponses = {
    /**
     * The created replica
     */
    201: {
        /**
         * Indicates if the replica was created successfully
         */
        success: boolean;
        /**
         * The replica UUID
         */
        uuid: string;
    };
};

export type PostV1ReplicasResponse = PostV1ReplicasResponses[keyof PostV1ReplicasResponses];

export type PostV1ApiKeysInvitesByCodeRedeemData = {
    body?: {
        /**
         * The name of the organization you want to create.
         */
        organizationName: string;
        /**
         * The name of the point of contact for the API subscription.
         */
        name: string;
        /**
         * The email of the point of contact for the API subscription.
         */
        email: string;
    };
    path: {
        /**
         * The code of the invite you want to redeem.
         */
        code: string;
    };
    query?: never;
    url: '/v1/api-keys/invites/{code}/redeem';
};

export type PostV1ApiKeysInvitesByCodeRedeemErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type PostV1ApiKeysInvitesByCodeRedeemError = PostV1ApiKeysInvitesByCodeRedeemErrors[keyof PostV1ApiKeysInvitesByCodeRedeemErrors];

export type PostV1ApiKeysInvitesByCodeRedeemResponses = {
    /**
     * Details about the created Organization and API Key.
     */
    200: {
        success: true;
        /**
         * The API key you will need to use to authenticate your requests. The key cannot be retrieved again after it is created: keep it safe.
         */
        apiKey: string;
        /**
         * The ID of the organization you have just created. You will need this ID to communicate with our team. Keep it safe.
         */
        organizationID: string;
        /**
         * The date until which the API subscroption is valid.
         */
        validUntil: string | null;
    };
};

export type PostV1ApiKeysInvitesByCodeRedeemResponse = PostV1ApiKeysInvitesByCodeRedeemResponses[keyof PostV1ApiKeysInvitesByCodeRedeemResponses];

export type GetV1TrainingData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by status
         */
        status?: 'AWAITING_UPLOAD' | 'SUPABASE_ONLY' | 'PROCESSING' | 'READY' | 'SYNC_ERROR' | 'ERR_FILE_PROCESSING' | 'ERR_TEXT_PROCESSING' | 'ERR_TEXT_TO_VECTOR';
        /**
         * Filter by type
         */
        type?: 'file_upload' | 'url' | 'training_history';
        /**
         * Page number (starts at 1)
         */
        page?: string;
        /**
         * Number of items per page (max 100)
         */
        limit?: string;
    };
    url: '/v1/training';
};

export type GetV1TrainingErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1TrainingError = GetV1TrainingErrors[keyof GetV1TrainingErrors];

export type GetV1TrainingResponses = {
    /**
     * List of knowledge base entries returned successfully.
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * Array of knowledge base entries
         */
        items: Array<{
            /**
             * Primary key ID of the knowledge base entry
             */
            id: number;
            /**
             * UUID of the Replica
             */
            replica_uuid: string | null;
            /**
             * Type of knowledge base entry
             */
            type: 'file_upload' | 'url' | 'training_history';
            /**
             * Name of the uploaded file
             */
            filename: string | null;
            /**
             * Current sync status of the knowledge base entry
             */
            status: 'AWAITING_UPLOAD' | 'SUPABASE_ONLY' | 'PROCESSING' | 'READY' | 'SYNC_ERROR' | 'ERR_FILE_PROCESSING' | 'ERR_TEXT_PROCESSING' | 'ERR_TEXT_TO_VECTOR';
            /**
             * Raw unprocessed text
             */
            raw_text: string | null;
            /**
             * Processed version of the text
             */
            processed_text: string | null;
            /**
             * Timestamp when the record was created
             */
            created_at: string;
            /**
             * Timestamp when the record was last updated
             */
            updated_at: string;
            /**
             * Title of the training entry
             */
            title: string | null;
            /**
             * Description of the training entry
             */
            description: string | null;
        }>;
    };
};

export type GetV1TrainingResponse = GetV1TrainingResponses[keyof GetV1TrainingResponses];

export type DeleteV1TrainingByTrainingIdData = {
    body?: never;
    path: {
        /**
         * The ID of the knowledge base entry to delete
         */
        trainingID: number;
    };
    query?: never;
    url: '/v1/training/{trainingID}';
};

export type DeleteV1TrainingByTrainingIdErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Knowledge base entry not found.
     */
    404: {
        success: false;
        /**
         * Error message
         */
        error: string;
        /**
         * Request ID for tracking
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type DeleteV1TrainingByTrainingIdError = DeleteV1TrainingByTrainingIdErrors[keyof DeleteV1TrainingByTrainingIdErrors];

export type DeleteV1TrainingByTrainingIdResponses = {
    /**
     * The knowledge base entry was deleted successfully.
     */
    200: {
        /**
         * Whether the operation was successful
         */
        success: boolean;
    };
};

export type DeleteV1TrainingByTrainingIdResponse = DeleteV1TrainingByTrainingIdResponses[keyof DeleteV1TrainingByTrainingIdResponses];

export type GetV1TrainingByTrainingIdData = {
    body?: never;
    path: {
        /**
         * The ID of the knowledge base entry to retrieve
         */
        trainingID: number;
    };
    query?: never;
    url: '/v1/training/{trainingID}';
};

export type GetV1TrainingByTrainingIdErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1TrainingByTrainingIdError = GetV1TrainingByTrainingIdErrors[keyof GetV1TrainingByTrainingIdErrors];

export type GetV1TrainingByTrainingIdResponses = {
    /**
     * The knowledge base entry returned successfully.
     */
    200: {
        /**
         * Primary key ID of the knowledge base entry
         */
        id: number;
        /**
         * UUID of the Replica
         */
        replica_uuid: string | null;
        /**
         * Type of knowledge base entry
         */
        type: 'file_upload' | 'url' | 'training_history';
        /**
         * Name of the uploaded file
         */
        filename: string | null;
        /**
         * Current sync status of the knowledge base entry
         */
        status: 'AWAITING_UPLOAD' | 'SUPABASE_ONLY' | 'PROCESSING' | 'READY' | 'SYNC_ERROR' | 'ERR_FILE_PROCESSING' | 'ERR_TEXT_PROCESSING' | 'ERR_TEXT_TO_VECTOR';
        /**
         * Raw unprocessed text
         */
        raw_text: string | null;
        /**
         * Processed version of the text
         */
        processed_text: string | null;
        /**
         * Timestamp when the record was created
         */
        created_at: string;
        /**
         * Timestamp when the record was last updated
         */
        updated_at: string;
        /**
         * Title of the training entry
         */
        title: string | null;
        /**
         * Description of the training entry
         */
        description: string | null;
    };
};

export type GetV1TrainingByTrainingIdResponse = GetV1TrainingByTrainingIdResponses[keyof GetV1TrainingByTrainingIdResponses];

export type GetV1ReplicasByReplicaUuidChatHistoryData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/chat/history';
};

export type GetV1ReplicasByReplicaUuidChatHistoryErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * The replica specified could not be found or you do not have access to it
     */
    404: unknown;
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasByReplicaUuidChatHistoryError = GetV1ReplicasByReplicaUuidChatHistoryErrors[keyof GetV1ReplicasByReplicaUuidChatHistoryErrors];

export type GetV1ReplicasByReplicaUuidChatHistoryResponses = {
    /**
     * List the chat history of the replica by the currently logged in user
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        type: string;
        items?: Array<{
            /**
             * The content of the message
             */
            content: string;
            /**
             * The date and time the message was created
             */
            created_at: string;
            /**
             * The ID of the message
             */
            id: number;
            /**
             * Whether the replica is private
             */
            is_private: boolean;
            /**
             * The role of the message
             */
            role: 'user' | 'assistant';
            /**
             * From which platform is message was sent from
             */
            source: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot';
            /**
             * The sources of information used to create the response via RAG (Retrieval-Augmented Generation)
             */
            sources: Array<{
                /**
                 * The ID of the source
                 */
                id: number;
                /**
                 * Relevance score of the source
                 */
                score: number;
                /**
                 * If the source has ever been scored or not
                 */
                status: 'scored' | 'unscored';
                /**
                 * When the source was created
                 */
                created_at: string;
                /**
                 * The name of the source
                 */
                name: string;
                /**
                 * The actual content retrieved from the source
                 */
                content: string;
            }>;
            /**
             * The UUID of the user
             */
            user_uuid: string;
        }>;
    };
};

export type GetV1ReplicasByReplicaUuidChatHistoryResponse = GetV1ReplicasByReplicaUuidChatHistoryResponses[keyof GetV1ReplicasByReplicaUuidChatHistoryResponses];

export type PostV1ReplicasByReplicaUuidChatHistoryData = {
    body?: {
        /**
         * Content of the message
         */
        content: string;
        /**
         * The place where the conversation is happening, which informs where the message should be saved in the chat history.
         */
        source?: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot';
        discord_data?: {
            /**
             * Channel ID
             */
            channel_id: string;
            /**
             * Channel name
             */
            channel_name: string;
            /**
             * Author ID
             */
            author_id: string;
            /**
             * Author name
             */
            author_name: string;
            /**
             * Message ID
             */
            message_id: string;
            /**
             * Message creation timestamp
             */
            created_at?: string;
            /**
             * Server ID
             */
            server_id?: string;
            /**
             * Server name
             */
            server_name?: string;
        };
    };
    headers?: {
        'X-API-Version'?: string;
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/chat/history';
};

export type PostV1ReplicasByReplicaUuidChatHistoryErrors = {
    /**
     * The replica specified could not be found or you do not have access to it
     */
    404: unknown;
};

export type PostV1ReplicasByReplicaUuidChatHistoryResponses = {
    /**
     * Saves the chat history of the replica by the currently logged in user.
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
    };
};

export type PostV1ReplicasByReplicaUuidChatHistoryResponse = PostV1ReplicasByReplicaUuidChatHistoryResponses[keyof PostV1ReplicasByReplicaUuidChatHistoryResponses];

export type GetV1ReplicasByReplicaUuidChatHistoryTelegramData = {
    body?: never;
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/chat/history/telegram';
};

export type GetV1ReplicasByReplicaUuidChatHistoryTelegramErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * The replica specified could not be found or you do not have access to it
     */
    404: unknown;
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasByReplicaUuidChatHistoryTelegramError = GetV1ReplicasByReplicaUuidChatHistoryTelegramErrors[keyof GetV1ReplicasByReplicaUuidChatHistoryTelegramErrors];

export type GetV1ReplicasByReplicaUuidChatHistoryTelegramResponses = {
    /**
     * List the chat history of the replica by the currently logged in user
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        type: string;
        items?: Array<{
            /**
             * The content of the message
             */
            content: string;
            /**
             * The date and time the message was created
             */
            created_at: string;
            /**
             * The ID of the message
             */
            id: number;
            /**
             * Whether the replica is private
             */
            is_private: boolean;
            /**
             * The role of the message
             */
            role: 'user' | 'assistant';
            /**
             * From which platform is message was sent from
             */
            source: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot';
            /**
             * The sources of information used to create the response via RAG (Retrieval-Augmented Generation)
             */
            sources: Array<{
                /**
                 * The ID of the source
                 */
                id: number;
                /**
                 * Relevance score of the source
                 */
                score: number;
                /**
                 * If the source has ever been scored or not
                 */
                status: 'scored' | 'unscored';
                /**
                 * When the source was created
                 */
                created_at: string;
                /**
                 * The name of the source
                 */
                name: string;
                /**
                 * The actual content retrieved from the source
                 */
                content: string;
            }>;
            /**
             * The UUID of the user
             */
            user_uuid: string;
        }>;
    };
};

export type GetV1ReplicasByReplicaUuidChatHistoryTelegramResponse = GetV1ReplicasByReplicaUuidChatHistoryTelegramResponses[keyof GetV1ReplicasByReplicaUuidChatHistoryTelegramResponses];

export type PostV1ReplicasByReplicaUuidChatHistoryTelegramData = {
    body?: {
        /**
         * Content of the message
         */
        content: string;
        telegram_data: {
            /**
             * Type of the chat, can be either `private`, `group`, `supergroup` or `channel`.
             */
            chat_type: string;
            /**
             * Unique identifier for this chat.
             */
            chat_id: number;
            /**
             * Sender of the message's userID; may be empty for messages sent to channels. For backward compatibility, if the message was sent on behalf of a chat, the field contains a fake sender user in non-channel chats.
             */
            user_id?: number;
            /**
             * Sender of the message's username; may be empty for messages sent to channels. For backward compatibility, if the message was sent on behalf of a chat, the field contains a fake sender user in non-channel chats.
             */
            username?: string;
            /**
             * Unique message identifier inside this chat. In specific instances (e.g., message containing a video sent to a big chat).
             */
            message_id: number;
            /**
             * Unique identifier of a message thread or a forum topic to which the message belongs; for supergroups only.
             */
            message_thread_id?: number;
        };
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/chat/history/telegram';
};

export type PostV1ReplicasByReplicaUuidChatHistoryTelegramErrors = {
    /**
     * The replica specified could not be found or you do not have access to it
     */
    404: unknown;
};

export type PostV1ReplicasByReplicaUuidChatHistoryTelegramResponses = {
    /**
     * Saves the chat history of the replica by the currently logged in user.
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
    };
};

export type PostV1ReplicasByReplicaUuidChatHistoryTelegramResponse = PostV1ReplicasByReplicaUuidChatHistoryTelegramResponses[keyof PostV1ReplicasByReplicaUuidChatHistoryTelegramResponses];

export type GetV1ReplicasByReplicaUuidChatHistoryDiscordData = {
    body?: never;
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/chat/history/discord';
};

export type GetV1ReplicasByReplicaUuidChatHistoryDiscordErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * The replica specified could not be found or you do not have access to it
     */
    404: unknown;
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasByReplicaUuidChatHistoryDiscordError = GetV1ReplicasByReplicaUuidChatHistoryDiscordErrors[keyof GetV1ReplicasByReplicaUuidChatHistoryDiscordErrors];

export type GetV1ReplicasByReplicaUuidChatHistoryDiscordResponses = {
    /**
     * List the chat history of the replica by the currently logged in user
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        type: string;
        items?: Array<{
            /**
             * The content of the message
             */
            content: string;
            /**
             * The date and time the message was created
             */
            created_at: string;
            /**
             * The ID of the message
             */
            id: number;
            /**
             * Whether the replica is private
             */
            is_private: boolean;
            /**
             * The role of the message
             */
            role: 'user' | 'assistant';
            /**
             * From which platform is message was sent from
             */
            source: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot';
            /**
             * The sources of information used to create the response via RAG (Retrieval-Augmented Generation)
             */
            sources: Array<{
                /**
                 * The ID of the source
                 */
                id: number;
                /**
                 * Relevance score of the source
                 */
                score: number;
                /**
                 * If the source has ever been scored or not
                 */
                status: 'scored' | 'unscored';
                /**
                 * When the source was created
                 */
                created_at: string;
                /**
                 * The name of the source
                 */
                name: string;
                /**
                 * The actual content retrieved from the source
                 */
                content: string;
            }>;
            /**
             * The UUID of the user
             */
            user_uuid: string;
        }>;
    };
};

export type GetV1ReplicasByReplicaUuidChatHistoryDiscordResponse = GetV1ReplicasByReplicaUuidChatHistoryDiscordResponses[keyof GetV1ReplicasByReplicaUuidChatHistoryDiscordResponses];

export type GetV1ReplicasByReplicaUuidChatHistoryWebData = {
    body?: never;
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/chat/history/web';
};

export type GetV1ReplicasByReplicaUuidChatHistoryWebErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * The replica specified could not be found or you do not have access to it
     */
    404: unknown;
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasByReplicaUuidChatHistoryWebError = GetV1ReplicasByReplicaUuidChatHistoryWebErrors[keyof GetV1ReplicasByReplicaUuidChatHistoryWebErrors];

export type GetV1ReplicasByReplicaUuidChatHistoryWebResponses = {
    /**
     * List the chat history of the replica by the currently logged in user
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        type: string;
        items?: Array<{
            /**
             * The content of the message
             */
            content: string;
            /**
             * The date and time the message was created
             */
            created_at: string;
            /**
             * The ID of the message
             */
            id: number;
            /**
             * Whether the replica is private
             */
            is_private: boolean;
            /**
             * The role of the message
             */
            role: 'user' | 'assistant';
            /**
             * From which platform is message was sent from
             */
            source: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot';
            /**
             * The sources of information used to create the response via RAG (Retrieval-Augmented Generation)
             */
            sources: Array<{
                /**
                 * The ID of the source
                 */
                id: number;
                /**
                 * Relevance score of the source
                 */
                score: number;
                /**
                 * If the source has ever been scored or not
                 */
                status: 'scored' | 'unscored';
                /**
                 * When the source was created
                 */
                created_at: string;
                /**
                 * The name of the source
                 */
                name: string;
                /**
                 * The actual content retrieved from the source
                 */
                content: string;
            }>;
            /**
             * The UUID of the user
             */
            user_uuid: string;
        }>;
    };
};

export type GetV1ReplicasByReplicaUuidChatHistoryWebResponse = GetV1ReplicasByReplicaUuidChatHistoryWebResponses[keyof GetV1ReplicasByReplicaUuidChatHistoryWebResponses];

export type GetV1ReplicasByReplicaUuidChatHistoryEmbedData = {
    body?: never;
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/chat/history/embed';
};

export type GetV1ReplicasByReplicaUuidChatHistoryEmbedErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * The replica specified could not be found or you do not have access to it
     */
    404: unknown;
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasByReplicaUuidChatHistoryEmbedError = GetV1ReplicasByReplicaUuidChatHistoryEmbedErrors[keyof GetV1ReplicasByReplicaUuidChatHistoryEmbedErrors];

export type GetV1ReplicasByReplicaUuidChatHistoryEmbedResponses = {
    /**
     * List the chat history of the replica by the currently logged in user
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        type: string;
        items?: Array<{
            /**
             * The content of the message
             */
            content: string;
            /**
             * The date and time the message was created
             */
            created_at: string;
            /**
             * The ID of the message
             */
            id: number;
            /**
             * Whether the replica is private
             */
            is_private: boolean;
            /**
             * The role of the message
             */
            role: 'user' | 'assistant';
            /**
             * From which platform is message was sent from
             */
            source: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot';
            /**
             * The sources of information used to create the response via RAG (Retrieval-Augmented Generation)
             */
            sources: Array<{
                /**
                 * The ID of the source
                 */
                id: number;
                /**
                 * Relevance score of the source
                 */
                score: number;
                /**
                 * If the source has ever been scored or not
                 */
                status: 'scored' | 'unscored';
                /**
                 * When the source was created
                 */
                created_at: string;
                /**
                 * The name of the source
                 */
                name: string;
                /**
                 * The actual content retrieved from the source
                 */
                content: string;
            }>;
            /**
             * The UUID of the user
             */
            user_uuid: string;
        }>;
    };
};

export type GetV1ReplicasByReplicaUuidChatHistoryEmbedResponse = GetV1ReplicasByReplicaUuidChatHistoryEmbedResponses[keyof GetV1ReplicasByReplicaUuidChatHistoryEmbedResponses];

export type PostV1ReplicasByReplicaUuidChatCompletionsData = {
    body?: {
        /**
         * Content of the message must be between 1 and 10000 characters.
         */
        content: string;
        /**
         * When set to true, historical messages are not used in the context, and the message is not appended to the conversation history, thus it is excluded from all future chat context.
         */
        skip_chat_history?: boolean;
        /**
         * The place where the conversation is happening, which informs where the message should be saved in the chat history.
         */
        source?: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot';
        discord_data?: {
            /**
             * Channel ID
             */
            channel_id: string;
            /**
             * Channel name
             */
            channel_name: string;
            /**
             * Author ID
             */
            author_id: string;
            /**
             * Author name
             */
            author_name: string;
            /**
             * Message ID
             */
            message_id: string;
            /**
             * Message creation timestamp
             */
            created_at?: string;
            /**
             * Server ID
             */
            server_id?: string;
            /**
             * Server name
             */
            server_name?: string;
        };
    };
    headers?: {
        'X-API-Version'?: string;
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/chat/completions';
};

export type PostV1ReplicasByReplicaUuidChatCompletionsErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type PostV1ReplicasByReplicaUuidChatCompletionsError = PostV1ReplicasByReplicaUuidChatCompletionsErrors[keyof PostV1ReplicasByReplicaUuidChatCompletionsErrors];

export type PostV1ReplicasByReplicaUuidChatCompletionsResponses = {
    /**
     * List of chat messages had with a replica by the current user, including the completion
     */
    200: {
        success: boolean;
        content: string;
    };
};

export type PostV1ReplicasByReplicaUuidChatCompletionsResponse = PostV1ReplicasByReplicaUuidChatCompletionsResponses[keyof PostV1ReplicasByReplicaUuidChatCompletionsResponses];

export type PostV1ReplicasByReplicaUuidChatCompletionsTelegramData = {
    body?: {
        /**
         * Content of the message must be between 1 and 10000 characters.
         */
        content: string;
        /**
         * When set to true, historical messages are not used in the context, and the message is not appended to the conversation history, thus it is excluded from all future chat context.
         */
        skip_chat_history?: boolean;
        telegram_data: {
            /**
             * Type of the chat, can be either `private`, `group`, `supergroup` or `channel`.
             */
            chat_type: string;
            /**
             * Unique identifier for this chat.
             */
            chat_id: number;
            /**
             * Sender of the message's userID; may be empty for messages sent to channels. For backward compatibility, if the message was sent on behalf of a chat, the field contains a fake sender user in non-channel chats.
             */
            user_id?: number;
            /**
             * Sender of the message's username; may be empty for messages sent to channels. For backward compatibility, if the message was sent on behalf of a chat, the field contains a fake sender user in non-channel chats.
             */
            username?: string;
            /**
             * Unique message identifier inside this chat. In specific instances (e.g., message containing a video sent to a big chat).
             */
            message_id: number;
            /**
             * Unique identifier of a message thread or a forum topic to which the message belongs; for supergroups only.
             */
            message_thread_id?: number;
        };
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/chat/completions/telegram';
};

export type PostV1ReplicasByReplicaUuidChatCompletionsTelegramErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type PostV1ReplicasByReplicaUuidChatCompletionsTelegramError = PostV1ReplicasByReplicaUuidChatCompletionsTelegramErrors[keyof PostV1ReplicasByReplicaUuidChatCompletionsTelegramErrors];

export type PostV1ReplicasByReplicaUuidChatCompletionsTelegramResponses = {
    /**
     * List of chat messages had with a replica by the current user, including the completion
     */
    200: {
        success: boolean;
        content: string;
    };
};

export type PostV1ReplicasByReplicaUuidChatCompletionsTelegramResponse = PostV1ReplicasByReplicaUuidChatCompletionsTelegramResponses[keyof PostV1ReplicasByReplicaUuidChatCompletionsTelegramResponses];

export type PostV1ExperimentalReplicasByReplicaUuidChatCompletionsData = {
    body?: {
        /**
         * A list of messages that make up the conversation context. Only the last message is used for completion.
         */
        messages: Array<{
            /**
             * The role of the message author. Can be "assistant", "developer", "system", "tool", or "user".
             */
            role: 'assistant' | 'developer' | 'system' | 'tool' | 'user';
            /**
             * The content of the message.
             */
            content: string;
            /**
             * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
             */
            name?: string;
        }>;
        /**
         * When set to false, historical messages are not used in the context, and the message is not appended to the conversation history.
         */
        store?: boolean;
        /**
         * The place where the conversation is happening, which informs where the message should be saved in the chat history if `store` is true.
         */
        source?: 'discord' | 'embed' | 'web';
        discord_data?: {
            /**
             * Channel ID
             */
            channel_id: string;
            /**
             * Channel name
             */
            channel_name: string;
            /**
             * Author ID
             */
            author_id: string;
            /**
             * Author name
             */
            author_name: string;
            /**
             * Message ID
             */
            message_id: string;
            /**
             * Message creation timestamp
             */
            created_at?: string;
            /**
             * Server ID
             */
            server_id?: string;
            /**
             * Server name
             */
            server_name?: string;
        };
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/experimental/replicas/{replicaUUID}/chat/completions';
};

export type PostV1ExperimentalReplicasByReplicaUuidChatCompletionsErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type PostV1ExperimentalReplicasByReplicaUuidChatCompletionsError = PostV1ExperimentalReplicasByReplicaUuidChatCompletionsErrors[keyof PostV1ExperimentalReplicasByReplicaUuidChatCompletionsErrors];

export type PostV1ExperimentalReplicasByReplicaUuidChatCompletionsResponses = {
    /**
     * The response format for chat completions.
     */
    200: {
        /**
         * A unique identifier for the chat completion.
         */
        id: string;
        /**
         * The Unix timestamp (in seconds) of when the chat completion was created.
         */
        created: number;
        /**
         * The object type, which is always "chat.completion"
         */
        object: 'chat.completion';
        /**
         * The model used for the chat completion.
         */
        model: string;
        /**
         * An array of chat completion choices.
         */
        choices: Array<{
            /**
             * The index of the choice in the array.
             */
            index: number;
            /**
             * The message generated by the model.
             */
            message: {
                /**
                 * The role of the message author, which is always "assistant" for completions.
                 */
                role: 'assistant';
                /**
                 * The content of the message.
                 */
                content: string;
                /**
                 * The tool calls generated by the model, such as function calls.
                 */
                tool_calls?: Array<unknown>;
            };
            /**
             * Log probabilities for token generation if requested.
             */
            logprobs?: unknown;
            /**
             * The reason the model stopped generating tokens.
             */
            finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';
        }>;
        /**
         * Usage statistics for the completion request.
         */
        usage: {
            /**
             * Number of tokens in the prompt.
             */
            prompt_tokens: number;
            /**
             * Number of tokens in the generated completion.
             */
            completion_tokens: number;
            /**
             * Total number of tokens used (prompt + completion).
             */
            total_tokens: number;
        };
    };
};

export type PostV1ExperimentalReplicasByReplicaUuidChatCompletionsResponse = PostV1ExperimentalReplicasByReplicaUuidChatCompletionsResponses[keyof PostV1ExperimentalReplicasByReplicaUuidChatCompletionsResponses];

export type DeleteV1UsersMeData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/users/me';
};

export type DeleteV1UsersMeErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type DeleteV1UsersMeError = DeleteV1UsersMeErrors[keyof DeleteV1UsersMeErrors];

export type DeleteV1UsersMeResponses = {
    /**
     * User deleted successfully
     */
    204: void;
};

export type DeleteV1UsersMeResponse = DeleteV1UsersMeResponses[keyof DeleteV1UsersMeResponses];

export type GetV1UsersMeData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/users/me';
};

export type GetV1UsersMeResponses = {
    /**
     * User information
     */
    200: {
        /**
         * The name of the user
         */
        name?: string;
        /**
         * The email address
         */
        email?: string;
        /**
         * The ID of the user
         */
        id: string;
        linkedAccounts?: TheLinkedAccountsOfTheUser;
    };
};

export type GetV1UsersMeResponse = GetV1UsersMeResponses[keyof GetV1UsersMeResponses];

export type PutV1UsersMeData = {
    body?: {
        /**
         * The name of the user
         */
        name?: string;
        /**
         * The email address
         */
        email?: string;
        /**
         * The ID of the user
         */
        id: string;
        linkedAccounts?: TheLinkedAccountsOfTheUser;
    };
    headers?: {
        'X-API-Version'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/users/me';
};

export type PutV1UsersMeErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Linked account or email already exists or is invalid
     */
    409: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type PutV1UsersMeError = PutV1UsersMeErrors[keyof PutV1UsersMeErrors];

export type PutV1UsersMeResponses = {
    /**
     * The updated User entity
     */
    200: {
        /**
         * The name of the user
         */
        name?: string;
        /**
         * The email address
         */
        email?: string;
        /**
         * The ID of the user
         */
        id: string;
        linkedAccounts?: TheLinkedAccountsOfTheUser;
    };
};

export type PutV1UsersMeResponse = PutV1UsersMeResponses[keyof PutV1UsersMeResponses];

export type PostV1UsersData = {
    body?: {
        /**
         * The name of the user
         */
        name?: string;
        /**
         * The email address
         */
        email?: string;
        /**
         * The ID of the user
         */
        id?: string;
        linkedAccounts?: TheLinkedAccountsOfTheUser;
    };
    headers?: {
        'X-API-Version'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/users';
};

export type PostV1UsersErrors = {
    /**
     * User, email, or linked account already exists
     */
    409: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
};

export type PostV1UsersError = PostV1UsersErrors[keyof PostV1UsersErrors];

export type PostV1UsersResponses = {
    /**
     * The created User entity
     */
    200: {
        /**
         * The name of the user
         */
        name?: string;
        /**
         * The email address
         */
        email?: string;
        /**
         * The ID of the user
         */
        id: string;
        linkedAccounts?: TheLinkedAccountsOfTheUser;
    };
};

export type PostV1UsersResponse = PostV1UsersResponses[keyof PostV1UsersResponses];

export type GetV1UsersByUserIdData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path: {
        /**
         * User ID
         */
        userID: string;
    };
    query?: never;
    url: '/v1/users/{userID}';
};

export type GetV1UsersByUserIdErrors = {
    /**
     * User not found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
};

export type GetV1UsersByUserIdError = GetV1UsersByUserIdErrors[keyof GetV1UsersByUserIdErrors];

export type GetV1UsersByUserIdResponses = {
    /**
     * User entity
     */
    200: {
        /**
         * The name of the user
         */
        name?: string;
        /**
         * The email address
         */
        email?: string;
        /**
         * The ID of the user
         */
        id: string;
        linkedAccounts?: TheLinkedAccountsOfTheUser;
    };
};

export type GetV1UsersByUserIdResponse = GetV1UsersByUserIdResponses[keyof GetV1UsersByUserIdResponses];

export type GetV1ReplicasByReplicaUuidTrainingFilesUploadData = {
    body?: never;
    path: {
        /**
         * The UUID of the replica to upload the file to
         */
        replicaUUID: string;
    };
    query: {
        /**
         * The name of the file to upload
         */
        filename: string;
    };
    url: '/v1/replicas/{replicaUUID}/training/files/upload';
};

export type GetV1ReplicasByReplicaUuidTrainingFilesUploadErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasByReplicaUuidTrainingFilesUploadError = GetV1ReplicasByReplicaUuidTrainingFilesUploadErrors[keyof GetV1ReplicasByReplicaUuidTrainingFilesUploadErrors];

export type GetV1ReplicasByReplicaUuidTrainingFilesUploadResponses = {
    /**
     * The generated signed URL
     */
    200: {
        /**
         * Indicates if the signed URL was generated successfully
         */
        success: boolean;
        /**
         * The signed URL for uploading the file
         */
        signedURL?: string;
    };
};

export type GetV1ReplicasByReplicaUuidTrainingFilesUploadResponse = GetV1ReplicasByReplicaUuidTrainingFilesUploadResponses[keyof GetV1ReplicasByReplicaUuidTrainingFilesUploadResponses];

export type DeleteV1ReplicasByReplicaUuidIntegrationsTelegramData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/replicas/{replicaUUID}/integrations/telegram';
};

export type DeleteV1ReplicasByReplicaUuidIntegrationsTelegramErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type DeleteV1ReplicasByReplicaUuidIntegrationsTelegramError = DeleteV1ReplicasByReplicaUuidIntegrationsTelegramErrors[keyof DeleteV1ReplicasByReplicaUuidIntegrationsTelegramErrors];

export type DeleteV1ReplicasByReplicaUuidIntegrationsTelegramResponses = {
    /**
     * Deletes integration for telegram
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
    };
};

export type DeleteV1ReplicasByReplicaUuidIntegrationsTelegramResponse = DeleteV1ReplicasByReplicaUuidIntegrationsTelegramResponses[keyof DeleteV1ReplicasByReplicaUuidIntegrationsTelegramResponses];

export type PostV1ReplicasByReplicaUuidIntegrationsTelegramData = {
    body?: {
        /**
         * Telegram Bot ID
         */
        telegram_token: string;
        /**
         * Telegram Bot Name
         */
        mention: string;
    };
    headers?: {
        'X-API-Version'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/replicas/{replicaUUID}/integrations/telegram';
};

export type PostV1ReplicasByReplicaUuidIntegrationsTelegramErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type PostV1ReplicasByReplicaUuidIntegrationsTelegramError = PostV1ReplicasByReplicaUuidIntegrationsTelegramErrors[keyof PostV1ReplicasByReplicaUuidIntegrationsTelegramErrors];

export type PostV1ReplicasByReplicaUuidIntegrationsTelegramResponses = {
    /**
     * Adds integrations for telegram
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        id: number;
    };
};

export type PostV1ReplicasByReplicaUuidIntegrationsTelegramResponse = PostV1ReplicasByReplicaUuidIntegrationsTelegramResponses[keyof PostV1ReplicasByReplicaUuidIntegrationsTelegramResponses];

export type DeleteV1ReplicasByReplicaUuidData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/replicas/{replicaUUID}';
};

export type DeleteV1ReplicasByReplicaUuidErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type DeleteV1ReplicasByReplicaUuidError = DeleteV1ReplicasByReplicaUuidErrors[keyof DeleteV1ReplicasByReplicaUuidErrors];

export type DeleteV1ReplicasByReplicaUuidResponses = {
    /**
     * Replica has been deleted
     */
    200: {
        /**
         * Indicates if the replica was deleted successfully
         */
        success: boolean;
    };
};

export type DeleteV1ReplicasByReplicaUuidResponse = DeleteV1ReplicasByReplicaUuidResponses[keyof DeleteV1ReplicasByReplicaUuidResponses];

export type GetV1ReplicasByReplicaUuidData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/replicas/{replicaUUID}';
};

export type GetV1ReplicasByReplicaUuidErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasByReplicaUuidError = GetV1ReplicasByReplicaUuidErrors[keyof GetV1ReplicasByReplicaUuidErrors];

export type GetV1ReplicasByReplicaUuidResponses = {
    /**
     * The requested replica
     */
    200: {
        /**
         * The name of the replica.
         */
        name: string;
        /**
         * A short description of your replica's purpose or personality.
         */
        shortDescription: string;
        /**
         * The first thing your replica will say when you start a conversation with them.
         */
        greeting: string;
        /**
         * The replica type.
         * `individual`: A replica of yourself.
         * `character`: A replica of a character: can be anything you want.
         * `brand`: A replica of a business persona or organization.
         */
        type?: 'individual' | 'character' | 'brand';
        /**
         * The replica owner ID.
         */
        ownerID: string;
        /**
         * Visibility of the replica. When set to `true`, only the owner will be able to find the replica and chat with it.
         */
        private?: boolean;
        /**
         * Emails of users who can use the replica.
         */
        whitelistEmails?: Array<string>;
        /**
         * The slug of the replica. Slugs can be used by API consumers to determine the URLs where replicas can be found.
         */
        slug: string;
        /**
         * The tags associated with the replica. Tags help categorize replicas and make them easier to find.
         */
        tags?: Array<string>;
        /**
         * The URL of the profile image of the replica. The image will be downloaded, optimized and stored on our servers, so the URL in the response will be different. Supported formats: .jpg, .jpeg, .png, .bmp, .webp, .avif
         */
        profileImage?: string;
        /**
         * Suggested questions when starting a conversation.
         */
        suggestedQuestions?: Array<string>;
        llm: {
            /**
             * The LLM model of the replica.
             */
            model?: 'gpt-4o' | 'claude-3-5-haiku-latest' | 'claude-3-7-sonnet-latest' | 'grok-2-latest' | 'deepseek-chat' | 'o3-mini' | 'gpt-4o-mini' | 'huggingface-eva' | 'huggingface-dolphin-llama';
            /**
             * The memory mode of the replica.
             */
            memoryMode?: 'prompt-caching' | 'rag-search';
            /**
             * Who is your replica? How do you want it to talk, respond and act.
             */
            systemMessage?: string;
            /**
             * The replica's tools. Tools enable agents to interact with the world.
             */
            tools?: Array<'getTokenInfo' | 'getUdaoTokenInfo' | 'getSensayTokenInfo' | 'getTokenInfoMEAI' | 'answerToLife' | 'toolhouse'>;
        };
        /**
         * The replica UUID
         */
        uuid: string;
    };
};

export type GetV1ReplicasByReplicaUuidResponse = GetV1ReplicasByReplicaUuidResponses[keyof GetV1ReplicasByReplicaUuidResponses];

export type PutV1ReplicasByReplicaUuidData = {
    body?: {
        /**
         * The name of the replica.
         */
        name: string;
        /**
         * A short description of your replica's purpose or personality.
         */
        shortDescription: string;
        /**
         * The first thing your replica will say when you start a conversation with them.
         */
        greeting: string;
        /**
         * The replica type.
         * `individual`: A replica of yourself.
         * `character`: A replica of a character: can be anything you want.
         * `brand`: A replica of a business persona or organization.
         */
        type?: 'individual' | 'character' | 'brand';
        /**
         * The replica owner ID.
         */
        ownerID: string;
        /**
         * Visibility of the replica. When set to `true`, only the owner will be able to find the replica and chat with it.
         */
        private?: boolean;
        /**
         * Emails of users who can use the replica.
         */
        whitelistEmails?: Array<string>;
        /**
         * The slug of the replica. Slugs can be used by API consumers to determine the URLs where replicas can be found.
         */
        slug: string;
        /**
         * The tags associated with the replica. Tags help categorize replicas and make them easier to find.
         */
        tags?: Array<string>;
        /**
         * The URL of the profile image of the replica. The image will be downloaded, optimized and stored on our servers, so the URL in the response will be different. Supported formats: .jpg, .jpeg, .png, .bmp, .webp, .avif
         */
        profileImage?: string;
        /**
         * Suggested questions when starting a conversation.
         */
        suggestedQuestions?: Array<string>;
        llm: {
            /**
             * The LLM model of the replica.
             */
            model?: 'gpt-4o' | 'claude-3-5-haiku-latest' | 'claude-3-7-sonnet-latest' | 'grok-2-latest' | 'deepseek-chat' | 'o3-mini' | 'gpt-4o-mini' | 'huggingface-eva' | 'huggingface-dolphin-llama';
            /**
             * The memory mode of the replica.
             */
            memoryMode?: 'prompt-caching' | 'rag-search';
            /**
             * Who is your replica? How do you want it to talk, respond and act.
             */
            systemMessage?: string;
            /**
             * The replica's tools. Tools enable agents to interact with the world.
             */
            tools?: Array<'getTokenInfo' | 'getUdaoTokenInfo' | 'getSensayTokenInfo' | 'getTokenInfoMEAI' | 'answerToLife' | 'toolhouse'>;
        };
    };
    headers?: {
        'X-API-Version'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/replicas/{replicaUUID}';
};

export type PutV1ReplicasByReplicaUuidErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Conflict
     */
    409: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type PutV1ReplicasByReplicaUuidError = PutV1ReplicasByReplicaUuidErrors[keyof PutV1ReplicasByReplicaUuidErrors];

export type PutV1ReplicasByReplicaUuidResponses = {
    /**
     * The request outcome
     */
    200: {
        /**
         * Indicates if the replica was created successfully
         */
        success: boolean;
    };
};

export type PutV1ReplicasByReplicaUuidResponse = PutV1ReplicasByReplicaUuidResponses[keyof PutV1ReplicasByReplicaUuidResponses];

export type ClientOptions = {
    baseUrl: 'https://api.sensay.io' | (string & {});
};