// This file is auto-generated by @hey-api/openapi-ts

import type { Options as ClientOptions, TDataShape, Client } from '@hey-api/client-fetch';
import type { GetV1ReplicasData, GetV1ReplicasResponse, GetV1ReplicasError, PostV1ReplicasData, PostV1ReplicasResponse, PostV1ReplicasError, PostV1ApiKeysInvitesByCodeRedeemData, PostV1ApiKeysInvitesByCodeRedeemResponse, PostV1ApiKeysInvitesByCodeRedeemError, GetV1ReplicasByReplicaUuidChatHistoryData, GetV1ReplicasByReplicaUuidChatHistoryResponse, GetV1ReplicasByReplicaUuidChatHistoryError, PostV1ReplicasByReplicaUuidChatHistoryData, PostV1ReplicasByReplicaUuidChatHistoryResponse, GetV1ReplicasByReplicaUuidChatHistoryTelegramData, GetV1ReplicasByReplicaUuidChatHistoryTelegramResponse, GetV1ReplicasByReplicaUuidChatHistoryTelegramError, PostV1ReplicasByReplicaUuidChatHistoryTelegramData, PostV1ReplicasByReplicaUuidChatHistoryTelegramResponse, GetV1ReplicasByReplicaUuidChatHistoryDiscordData, GetV1ReplicasByReplicaUuidChatHistoryDiscordResponse, GetV1ReplicasByReplicaUuidChatHistoryDiscordError, GetV1ReplicasByReplicaUuidChatHistoryWebData, GetV1ReplicasByReplicaUuidChatHistoryWebResponse, GetV1ReplicasByReplicaUuidChatHistoryWebError, GetV1ReplicasByReplicaUuidChatHistoryEmbedData, GetV1ReplicasByReplicaUuidChatHistoryEmbedResponse, GetV1ReplicasByReplicaUuidChatHistoryEmbedError, PostV1ReplicasByReplicaUuidChatCompletionsData, PostV1ReplicasByReplicaUuidChatCompletionsResponse, PostV1ReplicasByReplicaUuidChatCompletionsError, PostV1ReplicasByReplicaUuidChatCompletionsTelegramData, PostV1ReplicasByReplicaUuidChatCompletionsTelegramResponse, PostV1ReplicasByReplicaUuidChatCompletionsTelegramError, PostV1ExperimentalReplicasByReplicaUuidChatCompletionsData, PostV1ExperimentalReplicasByReplicaUuidChatCompletionsResponse, PostV1ExperimentalReplicasByReplicaUuidChatCompletionsError, DeleteV1UsersMeData, DeleteV1UsersMeResponse, DeleteV1UsersMeError, GetV1UsersMeData, GetV1UsersMeResponse, PutV1UsersMeData, PutV1UsersMeResponse, PutV1UsersMeError, PostV1UsersData, PostV1UsersResponse, PostV1UsersError, GetV1UsersByUserIdData, GetV1UsersByUserIdResponse, GetV1UsersByUserIdError, DeleteV1ReplicasByReplicaUuidIntegrationsTelegramData, DeleteV1ReplicasByReplicaUuidIntegrationsTelegramResponse, DeleteV1ReplicasByReplicaUuidIntegrationsTelegramError, PostV1ReplicasByReplicaUuidIntegrationsTelegramData, PostV1ReplicasByReplicaUuidIntegrationsTelegramResponse, PostV1ReplicasByReplicaUuidIntegrationsTelegramError, DeleteV1ReplicasByReplicaUuidData, DeleteV1ReplicasByReplicaUuidResponse, DeleteV1ReplicasByReplicaUuidError, GetV1ReplicasByReplicaUuidData, GetV1ReplicasByReplicaUuidResponse, GetV1ReplicasByReplicaUuidError, PutV1ReplicasByReplicaUuidData, PutV1ReplicasByReplicaUuidResponse, PutV1ReplicasByReplicaUuidError, GetV1ReplicasByReplicaUuidConversationsByConversationUuidData, GetV1ReplicasByReplicaUuidConversationsByConversationUuidResponse, GetV1ReplicasByReplicaUuidConversationsByConversationUuidError, GetV1ReplicasByReplicaUuidConversationsData, GetV1ReplicasByReplicaUuidConversationsResponse, GetV1ReplicasByReplicaUuidConversationsError, GetV1ReplicasByReplicaUuidConversationsByConversationUuidMentionsData, GetV1ReplicasByReplicaUuidConversationsByConversationUuidMentionsResponse, GetV1ReplicasByReplicaUuidConversationsByConversationUuidMentionsError, GetV1ReplicasByReplicaUuidConversationsByConversationUuidMessagesData, GetV1ReplicasByReplicaUuidConversationsByConversationUuidMessagesResponse, GetV1ReplicasByReplicaUuidConversationsByConversationUuidMessagesError, GetV1ReplicasByReplicaUuidAnalyticsConversationsHistoricalData, GetV1ReplicasByReplicaUuidAnalyticsConversationsHistoricalResponse, GetV1ReplicasByReplicaUuidAnalyticsConversationsHistoricalError, GetV1ReplicasByReplicaUuidAnalyticsConversationsSourcesData, GetV1ReplicasByReplicaUuidAnalyticsConversationsSourcesResponse, GetV1ReplicasByReplicaUuidAnalyticsConversationsSourcesError, PostV1ReplicasByReplicaUuidTrainingData, PostV1ReplicasByReplicaUuidTrainingResponse, PostV1ReplicasByReplicaUuidTrainingError, PutV1ReplicasByReplicaUuidTrainingByTrainingIdData, PutV1ReplicasByReplicaUuidTrainingByTrainingIdResponse, PutV1ReplicasByReplicaUuidTrainingByTrainingIdError, DeleteV1TrainingByTrainingIdData, DeleteV1TrainingByTrainingIdResponse, DeleteV1TrainingByTrainingIdError, GetV1TrainingByTrainingIdData, GetV1TrainingByTrainingIdResponse, GetV1TrainingByTrainingIdError, GetV1TrainingData, GetV1TrainingResponse, GetV1TrainingError, GetV1ReplicasByReplicaUuidTrainingFilesUploadData, GetV1ReplicasByReplicaUuidTrainingFilesUploadResponse, GetV1ReplicasByReplicaUuidTrainingFilesUploadError, GetV1DebugInfoData, GetV1DebugInfoResponse, GetV1DebugInfoError, GetV1DebugExceptionData, GetV1DebugExceptionError, GetV1DebugValidationParamByUuidData, GetV1DebugValidationParamByUuidResponse, GetV1DebugValidationParamByUuidError, GetV1DebugValidationQueryData, GetV1DebugValidationQueryResponse, GetV1DebugValidationQueryError, PostV1DebugValidationJsonData, PostV1DebugValidationJsonResponse, PostV1DebugValidationJsonError, GetV1DebugFetchExceptionData, GetV1DebugFetchExceptionError, GetV1DebugApiErrorData, GetV1DebugApiErrorError, PostV1DebugIngestFileData, PostV1DebugIngestFileResponse } from './types.gen';
import { getV1ReplicasResponseTransformer, getV1ReplicasByReplicaUuidChatHistoryResponseTransformer, getV1ReplicasByReplicaUuidChatHistoryTelegramResponseTransformer, getV1ReplicasByReplicaUuidChatHistoryDiscordResponseTransformer, getV1ReplicasByReplicaUuidChatHistoryWebResponseTransformer, getV1ReplicasByReplicaUuidChatHistoryEmbedResponseTransformer, getV1ReplicasByReplicaUuidConversationsByConversationUuidResponseTransformer, getV1ReplicasByReplicaUuidConversationsResponseTransformer, getV1ReplicasByReplicaUuidConversationsByConversationUuidMentionsResponseTransformer, getV1ReplicasByReplicaUuidConversationsByConversationUuidMessagesResponseTransformer, getV1ReplicasByReplicaUuidAnalyticsConversationsHistoricalResponseTransformer, getV1TrainingByTrainingIdResponseTransformer, getV1TrainingResponseTransformer } from './transformers.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * List replicas
 * List replicas with pagination with optional filtering. Only Replicas that are public or belong to the authenticated user are returned.
 */
export const getV1Replicas = <ThrowOnError extends boolean = true>(options?: Options<GetV1ReplicasData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetV1ReplicasResponse, GetV1ReplicasError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            },
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        responseTransformer: getV1ReplicasResponseTransformer,
        url: '/v1/replicas',
        ...options
    });
};

/**
 * Create a replica
 * Creates a new replica.
 */
export const postV1Replicas = <ThrowOnError extends boolean = true>(options?: Options<PostV1ReplicasData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<PostV1ReplicasResponse, PostV1ReplicasError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        url: '/v1/replicas',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Redeem an API key invitation
 *
 * If you have an invitation code, you can redeem it to create an Organization and an API key associated with it.
 *
 */
export const postV1ApiKeysInvitesByCodeRedeem = <ThrowOnError extends boolean = true>(options: Options<PostV1ApiKeysInvitesByCodeRedeemData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostV1ApiKeysInvitesByCodeRedeemResponse, PostV1ApiKeysInvitesByCodeRedeemError, ThrowOnError>({
        url: '/v1/api-keys/invites/{code}/redeem',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get chat history
 * List chat history items of a Replica belonging to the logged in user.
 */
export const getV1ReplicasByReplicaUuidChatHistory = <ThrowOnError extends boolean = true>(options: Options<GetV1ReplicasByReplicaUuidChatHistoryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetV1ReplicasByReplicaUuidChatHistoryResponse, GetV1ReplicasByReplicaUuidChatHistoryError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            },
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        responseTransformer: getV1ReplicasByReplicaUuidChatHistoryResponseTransformer,
        url: '/v1/replicas/{replicaUUID}/chat/history',
        ...options
    });
};

/**
 * Create a chat history entry
 * Save chat history items of a Replica belonging to the logged in user.
 */
export const postV1ReplicasByReplicaUuidChatHistory = <ThrowOnError extends boolean = true>(options: Options<PostV1ReplicasByReplicaUuidChatHistoryData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostV1ReplicasByReplicaUuidChatHistoryResponse, unknown, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            },
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        url: '/v1/replicas/{replicaUUID}/chat/history',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get Telegram chat history
 * List telegram chat history items of a Replica belonging to the logged in user.
 */
export const getV1ReplicasByReplicaUuidChatHistoryTelegram = <ThrowOnError extends boolean = true>(options: Options<GetV1ReplicasByReplicaUuidChatHistoryTelegramData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetV1ReplicasByReplicaUuidChatHistoryTelegramResponse, GetV1ReplicasByReplicaUuidChatHistoryTelegramError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            },
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        responseTransformer: getV1ReplicasByReplicaUuidChatHistoryTelegramResponseTransformer,
        url: '/v1/replicas/{replicaUUID}/chat/history/telegram',
        ...options
    });
};

/**
 * Create a Telegram chat history entry
 * Save chat history items of a Replica belonging to the logged in user.
 */
export const postV1ReplicasByReplicaUuidChatHistoryTelegram = <ThrowOnError extends boolean = true>(options: Options<PostV1ReplicasByReplicaUuidChatHistoryTelegramData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostV1ReplicasByReplicaUuidChatHistoryTelegramResponse, unknown, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            },
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        url: '/v1/replicas/{replicaUUID}/chat/history/telegram',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get Discord chat history
 * List discord chat history items of a Replica belonging to the logged in user.
 */
export const getV1ReplicasByReplicaUuidChatHistoryDiscord = <ThrowOnError extends boolean = true>(options: Options<GetV1ReplicasByReplicaUuidChatHistoryDiscordData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetV1ReplicasByReplicaUuidChatHistoryDiscordResponse, GetV1ReplicasByReplicaUuidChatHistoryDiscordError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            },
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        responseTransformer: getV1ReplicasByReplicaUuidChatHistoryDiscordResponseTransformer,
        url: '/v1/replicas/{replicaUUID}/chat/history/discord',
        ...options
    });
};

/**
 * Get Web chat history
 * List web chat history items of a Replica belonging to the logged in user.
 */
export const getV1ReplicasByReplicaUuidChatHistoryWeb = <ThrowOnError extends boolean = true>(options: Options<GetV1ReplicasByReplicaUuidChatHistoryWebData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetV1ReplicasByReplicaUuidChatHistoryWebResponse, GetV1ReplicasByReplicaUuidChatHistoryWebError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            },
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        responseTransformer: getV1ReplicasByReplicaUuidChatHistoryWebResponseTransformer,
        url: '/v1/replicas/{replicaUUID}/chat/history/web',
        ...options
    });
};

/**
 * Get Embed chat history
 * List embed chat history items of a Replica belonging to the logged in user.
 */
export const getV1ReplicasByReplicaUuidChatHistoryEmbed = <ThrowOnError extends boolean = true>(options: Options<GetV1ReplicasByReplicaUuidChatHistoryEmbedData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetV1ReplicasByReplicaUuidChatHistoryEmbedResponse, GetV1ReplicasByReplicaUuidChatHistoryEmbedError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            },
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        responseTransformer: getV1ReplicasByReplicaUuidChatHistoryEmbedResponseTransformer,
        url: '/v1/replicas/{replicaUUID}/chat/history/embed',
        ...options
    });
};

/**
 * Generate a completion
 *
 * Ask for a completion and stores the prompt in the chat history.
 *
 * Replica chat supports two response formats: streamed and JSON. To switch between these formats, use the 'Accept' header, specifying either 'text/event-stream' for streaming or 'application/json' for JSON.
 * The streamed response honours the [Stream Protocol](https://sdk.vercel.ai/docs/ai-sdk-ui/stream-protocol), allowing the use of a number of SDKs, including [Vercel AI SDK](https://sdk.vercel.ai/docs/introduction).
 *
 * The streamed variant is not specified in the OpenAPI Schema because it is not an OpenAPI endpoint.
 *
 */
export const postV1ReplicasByReplicaUuidChatCompletions = <ThrowOnError extends boolean = true>(options: Options<PostV1ReplicasByReplicaUuidChatCompletionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostV1ReplicasByReplicaUuidChatCompletionsResponse, PostV1ReplicasByReplicaUuidChatCompletionsError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            },
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        url: '/v1/replicas/{replicaUUID}/chat/completions',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Generate a Telegram completion
 *
 * Ask for a completion and stores the prompt in the chat history.
 *
 * Replica chat supports two response formats: streamed and JSON. To switch between these formats, use the 'Accept' header, specifying either 'text/event-stream' for streaming or 'application/json' for JSON.
 * The streamed response honours the [Stream Protocol](https://sdk.vercel.ai/docs/ai-sdk-ui/stream-protocol), allowing the use of a number of SDKs, including [Vercel AI SDK](https://sdk.vercel.ai/docs/introduction).
 *
 * The streamed variant is not specified in the OpenAPI Schema because it is not an OpenAPI endpoint.
 *
 */
export const postV1ReplicasByReplicaUuidChatCompletionsTelegram = <ThrowOnError extends boolean = true>(options: Options<PostV1ReplicasByReplicaUuidChatCompletionsTelegramData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostV1ReplicasByReplicaUuidChatCompletionsTelegramResponse, PostV1ReplicasByReplicaUuidChatCompletionsTelegramError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            },
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        url: '/v1/replicas/{replicaUUID}/chat/completions/telegram',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Generate a completion (OpenAI-compatible, non-streaming)
 *
 * > warn
 * > Limited [OpenAI Chat Completions API](https://platform.openai.com/docs/api-reference/chat/create) compatibility.
 * > Supports basic chat completion with standard message roles and JSON responses.
 * > Not supported: OpenAI-style streaming, tool calls, stop sequences, logprobs, and most request parameters.
 *
 * Creates a chat completion response from a list of messages comprising a conversation.
 *
 */
export const postV1ExperimentalReplicasByReplicaUuidChatCompletions = <ThrowOnError extends boolean = true>(options: Options<PostV1ExperimentalReplicasByReplicaUuidChatCompletionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostV1ExperimentalReplicasByReplicaUuidChatCompletionsResponse, PostV1ExperimentalReplicasByReplicaUuidChatCompletionsError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            }
        ],
        url: '/v1/experimental/replicas/{replicaUUID}/chat/completions',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete the current user
 * This endpoint permanently deletes the currently authenticated user account, including all associated data. After deletion, the account cannot be recovered.
 */
export const deleteV1UsersMe = <ThrowOnError extends boolean = true>(options?: Options<DeleteV1UsersMeData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).delete<DeleteV1UsersMeResponse, DeleteV1UsersMeError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            }
        ],
        url: '/v1/users/me',
        ...options
    });
};

/**
 * Get the current user
 * Returns information about the current user.
 */
export const getV1UsersMe = <ThrowOnError extends boolean = true>(options?: Options<GetV1UsersMeData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetV1UsersMeResponse, unknown, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            }
        ],
        url: '/v1/users/me',
        ...options
    });
};

/**
 * Update the current user
 * Update the currently logged in user.
 */
export const putV1UsersMe = <ThrowOnError extends boolean = true>(options?: Options<PutV1UsersMeData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).put<PutV1UsersMeResponse, PutV1UsersMeError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            }
        ],
        url: '/v1/users/me',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Create a user
 * Creates a new user.
 */
export const postV1Users = <ThrowOnError extends boolean = true>(options?: Options<PostV1UsersData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<PostV1UsersResponse, PostV1UsersError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        url: '/v1/users',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get a user by ID
 * Returns information about the user with the specified ID.
 */
export const getV1UsersByUserId = <ThrowOnError extends boolean = true>(options: Options<GetV1UsersByUserIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetV1UsersByUserIdResponse, GetV1UsersByUserIdError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        url: '/v1/users/{userID}',
        ...options
    });
};

/**
 * Delete a replica Telegram integration
 * Removes a replica Telegram integration.
 */
export const deleteV1ReplicasByReplicaUuidIntegrationsTelegram = <ThrowOnError extends boolean = true>(options: Options<DeleteV1ReplicasByReplicaUuidIntegrationsTelegramData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteV1ReplicasByReplicaUuidIntegrationsTelegramResponse, DeleteV1ReplicasByReplicaUuidIntegrationsTelegramError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            },
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        url: '/v1/replicas/{replicaUUID}/integrations/telegram',
        ...options
    });
};

/**
 * Create a replica Telegram integration
 * Integrates a replica to Telegram. The default Sensay Telegram integration will run a bot for you until you delete the integration.
 */
export const postV1ReplicasByReplicaUuidIntegrationsTelegram = <ThrowOnError extends boolean = true>(options: Options<PostV1ReplicasByReplicaUuidIntegrationsTelegramData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostV1ReplicasByReplicaUuidIntegrationsTelegramResponse, PostV1ReplicasByReplicaUuidIntegrationsTelegramError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            },
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        url: '/v1/replicas/{replicaUUID}/integrations/telegram',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete a replica
 * Deletes a replica by UUID.
 */
export const deleteV1ReplicasByReplicaUuid = <ThrowOnError extends boolean = true>(options: Options<DeleteV1ReplicasByReplicaUuidData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteV1ReplicasByReplicaUuidResponse, DeleteV1ReplicasByReplicaUuidError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        url: '/v1/replicas/{replicaUUID}',
        ...options
    });
};

/**
 * Get a replica
 * Get an existing replica.
 */
export const getV1ReplicasByReplicaUuid = <ThrowOnError extends boolean = true>(options: Options<GetV1ReplicasByReplicaUuidData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetV1ReplicasByReplicaUuidResponse, GetV1ReplicasByReplicaUuidError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        url: '/v1/replicas/{replicaUUID}',
        ...options
    });
};

/**
 * Updates a replica
 * Updates an existing replica.
 */
export const putV1ReplicasByReplicaUuid = <ThrowOnError extends boolean = true>(options: Options<PutV1ReplicasByReplicaUuidData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<PutV1ReplicasByReplicaUuidResponse, PutV1ReplicasByReplicaUuidError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        url: '/v1/replicas/{replicaUUID}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Get conversation details
 * Retrieve details for a specific conversation within a replica.
 */
export const getV1ReplicasByReplicaUuidConversationsByConversationUuid = <ThrowOnError extends boolean = true>(options: Options<GetV1ReplicasByReplicaUuidConversationsByConversationUuidData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetV1ReplicasByReplicaUuidConversationsByConversationUuidResponse, GetV1ReplicasByReplicaUuidConversationsByConversationUuidError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            },
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        responseTransformer: getV1ReplicasByReplicaUuidConversationsByConversationUuidResponseTransformer,
        url: '/v1/replicas/{replicaUUID}/conversations/{conversationUUID}',
        ...options
    });
};

/**
 * List replica's conversations
 * List of replica's conversations with pagination and sorting.
 */
export const getV1ReplicasByReplicaUuidConversations = <ThrowOnError extends boolean = true>(options: Options<GetV1ReplicasByReplicaUuidConversationsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetV1ReplicasByReplicaUuidConversationsResponse, GetV1ReplicasByReplicaUuidConversationsError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            },
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        responseTransformer: getV1ReplicasByReplicaUuidConversationsResponseTransformer,
        url: '/v1/replicas/{replicaUUID}/conversations',
        ...options
    });
};

/**
 * List mentions in a conversation
 * Retrieves mentions of a replica in a specific conversation, together with context surrounding the mention. This endpoint supports cursor-based pagination. Returns most recent mentions first.
 */
export const getV1ReplicasByReplicaUuidConversationsByConversationUuidMentions = <ThrowOnError extends boolean = true>(options: Options<GetV1ReplicasByReplicaUuidConversationsByConversationUuidMentionsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetV1ReplicasByReplicaUuidConversationsByConversationUuidMentionsResponse, GetV1ReplicasByReplicaUuidConversationsByConversationUuidMentionsError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            },
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        responseTransformer: getV1ReplicasByReplicaUuidConversationsByConversationUuidMentionsResponseTransformer,
        url: '/v1/replicas/{replicaUUID}/conversations/{conversationUUID}/mentions',
        ...options
    });
};

/**
 * List messages in a conversation
 * Retrieves messages in a specific conversation with cursor-based pagination. Messages are sorted chronologically from oldest to newest.
 *
 * Use the `beforeUUID` parameter to get older messages and the `afterUUID` parameter to get newer messages. Please note:
 * - When `beforeUUID` is specified, the most recent messages before `beforeUUID` are returned.
 * - When `beforeUUID` and `afterUUID` are both specified, the most recent messages before `beforeUUID` are returned.
 * - When `afterUUID` is specified on its own, the least recent messages after `afterUUID` are returned.
 */
export const getV1ReplicasByReplicaUuidConversationsByConversationUuidMessages = <ThrowOnError extends boolean = true>(options: Options<GetV1ReplicasByReplicaUuidConversationsByConversationUuidMessagesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetV1ReplicasByReplicaUuidConversationsByConversationUuidMessagesResponse, GetV1ReplicasByReplicaUuidConversationsByConversationUuidMessagesError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            },
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        responseTransformer: getV1ReplicasByReplicaUuidConversationsByConversationUuidMessagesResponseTransformer,
        url: '/v1/replicas/{replicaUUID}/conversations/{conversationUUID}/messages',
        ...options
    });
};

/**
 * Get replica historical conversation analytics
 * Returns cumulative conversation count for the last 30 days, up to and including today.
 */
export const getV1ReplicasByReplicaUuidAnalyticsConversationsHistorical = <ThrowOnError extends boolean = true>(options: Options<GetV1ReplicasByReplicaUuidAnalyticsConversationsHistoricalData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetV1ReplicasByReplicaUuidAnalyticsConversationsHistoricalResponse, GetV1ReplicasByReplicaUuidAnalyticsConversationsHistoricalError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            },
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        responseTransformer: getV1ReplicasByReplicaUuidAnalyticsConversationsHistoricalResponseTransformer,
        url: '/v1/replicas/{replicaUUID}/analytics/conversations/historical',
        ...options
    });
};

/**
 * Get replica source analytics
 * Returns interaction counts by source for the replica.
 */
export const getV1ReplicasByReplicaUuidAnalyticsConversationsSources = <ThrowOnError extends boolean = true>(options: Options<GetV1ReplicasByReplicaUuidAnalyticsConversationsSourcesData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetV1ReplicasByReplicaUuidAnalyticsConversationsSourcesResponse, GetV1ReplicasByReplicaUuidAnalyticsConversationsSourcesError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            },
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        url: '/v1/replicas/{replicaUUID}/analytics/conversations/sources',
        ...options
    });
};

/**
 * Create a knowledge base entry
 * Creates a new empty knowledge base entry for a replica. This is the first step in the text-based training process. After creating the entry, you'll receive a knowledgeBaseID that you'll need to use in the next step to add your training content using the Update endpoint. The entry starts with a BLANK status and will be processed automatically once you add content.
 */
export const postV1ReplicasByReplicaUuidTraining = <ThrowOnError extends boolean = true>(options: Options<PostV1ReplicasByReplicaUuidTrainingData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostV1ReplicasByReplicaUuidTrainingResponse, PostV1ReplicasByReplicaUuidTrainingError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        url: '/v1/replicas/{replicaUUID}/training',
        ...options
    });
};

/**
 * Update knowledge base entry
 * Updates a knowledge base entry with training content. This is the second step in the training process after creating an entry. You can provide "rawText" which is the content you want your replica to learn from (such as product information, company policies, or specialized knowledge). The system will automatically process this text and make it available for your replica to use when answering questions. The entry status will change to PROCESSING and then to READY once fully processed.
 */
export const putV1ReplicasByReplicaUuidTrainingByTrainingId = <ThrowOnError extends boolean = true>(options: Options<PutV1ReplicasByReplicaUuidTrainingByTrainingIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<PutV1ReplicasByReplicaUuidTrainingByTrainingIdResponse, PutV1ReplicasByReplicaUuidTrainingByTrainingIdError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        url: '/v1/replicas/{replicaUUID}/training/{trainingID}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete knowledge base entry by ID
 * Permanently removes a specific knowledge base entry and its associated vector database entry. Use this endpoint when you need to remove outdated or incorrect training data from your replica's knowledge base. This operation cannot be undone, and the entry will no longer be available for retrieval during conversations with your replica. This endpoint handles the complete cleanup process, removing both the database record and any associated vector embeddings.
 */
export const deleteV1TrainingByTrainingId = <ThrowOnError extends boolean = true>(options: Options<DeleteV1TrainingByTrainingIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteV1TrainingByTrainingIdResponse, DeleteV1TrainingByTrainingIdError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        url: '/v1/training/{trainingID}',
        ...options
    });
};

/**
 * Get knowledge base entry by ID
 * Retrieves detailed information about a specific knowledge base entry using its ID. This endpoint returns the complete entry data including its type, status, content, and metadata. You can use this to check the processing status of your training content, view the raw and processed text, and see when it was created and last updated. This is useful for monitoring the progress of your training data as it moves through the processing pipeline.
 */
export const getV1TrainingByTrainingId = <ThrowOnError extends boolean = true>(options: Options<GetV1TrainingByTrainingIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetV1TrainingByTrainingIdResponse, GetV1TrainingByTrainingIdError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        responseTransformer: getV1TrainingByTrainingIdResponseTransformer,
        url: '/v1/training/{trainingID}',
        ...options
    });
};

/**
 * List all knowledge base entries
 * Returns a list of all knowledge base entries belonging to your organization. This endpoint allows you to view all your training data in one place, with optional filtering by status or type. You can use this to monitor the overall state of your knowledge base, check which entries are still processing, and identify any that might have encountered errors. The response includes detailed information about each entry including its content, status, and metadata.
 */
export const getV1Training = <ThrowOnError extends boolean = true>(options?: Options<GetV1TrainingData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetV1TrainingResponse, GetV1TrainingError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        responseTransformer: getV1TrainingResponseTransformer,
        url: '/v1/training',
        ...options
    });
};

/**
 * Generate a signed URL for file upload
 * Creates a signed URL for uploading a file to the knowledge base. This is the first step in the file-based training process. The response includes both a signedURL where you can upload your file and a knowledgeBaseID for tracking. After receiving these, use a PUT request to the signedURL to upload your file (with Content-Type: application/octet-stream). The system will automatically extract text from your file, process it, and make it available for your replica to use. Supported file types include PDF, DOCX, and other text-based formats. Files up to 50MB are supported.
 */
export const getV1ReplicasByReplicaUuidTrainingFilesUpload = <ThrowOnError extends boolean = true>(options: Options<GetV1ReplicasByReplicaUuidTrainingFilesUploadData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetV1ReplicasByReplicaUuidTrainingFilesUploadResponse, GetV1ReplicasByReplicaUuidTrainingFilesUploadError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        url: '/v1/replicas/{replicaUUID}/training/files/upload',
        ...options
    });
};

export const getV1DebugInfo = <ThrowOnError extends boolean = true>(options?: Options<GetV1DebugInfoData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetV1DebugInfoResponse, GetV1DebugInfoError, ThrowOnError>({
        security: [
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID',
                type: 'apiKey'
            },
            {
                name: 'X-USER-ID-TYPE',
                type: 'apiKey'
            },
            {
                name: 'X-ORGANIZATION-SECRET',
                type: 'apiKey'
            }
        ],
        url: '/v1/debug/info',
        ...options
    });
};

export const getV1DebugException = <ThrowOnError extends boolean = true>(options?: Options<GetV1DebugExceptionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<unknown, GetV1DebugExceptionError, ThrowOnError>({
        url: '/v1/debug/exception',
        ...options
    });
};

/**
 * This endpoint designed to test validation of url params
 */
export const getV1DebugValidationParamByUuid = <ThrowOnError extends boolean = true>(options: Options<GetV1DebugValidationParamByUuidData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetV1DebugValidationParamByUuidResponse, GetV1DebugValidationParamByUuidError, ThrowOnError>({
        url: '/v1/debug/validation/param/{UUID}',
        ...options
    });
};

/**
 * This endpoint designed to test validation of query string
 */
export const getV1DebugValidationQuery = <ThrowOnError extends boolean = true>(options?: Options<GetV1DebugValidationQueryData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetV1DebugValidationQueryResponse, GetV1DebugValidationQueryError, ThrowOnError>({
        url: '/v1/debug/validation/query',
        ...options
    });
};

/**
 * This endpoint designed to test validation of json body.
 */
export const postV1DebugValidationJson = <ThrowOnError extends boolean = true>(options?: Options<PostV1DebugValidationJsonData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<PostV1DebugValidationJsonResponse, PostV1DebugValidationJsonError, ThrowOnError>({
        url: '/v1/debug/validation/json',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

export const getV1DebugFetchException = <ThrowOnError extends boolean = true>(options?: Options<GetV1DebugFetchExceptionData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<unknown, GetV1DebugFetchExceptionError, ThrowOnError>({
        url: '/v1/debug/fetch-exception',
        ...options
    });
};

export const getV1DebugApiError = <ThrowOnError extends boolean = true>(options?: Options<GetV1DebugApiErrorData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<unknown, GetV1DebugApiErrorError, ThrowOnError>({
        url: '/v1/debug/api-error',
        ...options
    });
};

export const postV1DebugIngestFile = <ThrowOnError extends boolean = true>(options?: Options<PostV1DebugIngestFileData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).post<PostV1DebugIngestFileResponse, unknown, ThrowOnError>({
        url: '/v1/debug/ingest-file',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};