// This file is auto-generated by @hey-api/openapi-ts

/**
 * The UUID of the Replica
 */
export type ReplicaUuidParameter = string

export type TheLinkedAccountsOfTheUser = Array<{
  /**
   * The account ID
   */
  accountID: string
  /**
   * The account type
   */
  accountType: 'discord' | 'telegram' | 'embed'
}>

export type PostV1ReplicasByReplicaUuidTrainingData = {
  body?: never
  headers?: {
    'X-API-Version'?: string
  }
  path: {
    replicaUUID: ReplicaUuidParameter
  }
  query?: never
  url: '/v1/replicas/{replicaUUID}/training'
}

export type PostV1ReplicasByReplicaUuidTrainingErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Not Found
   */
  404: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type PostV1ReplicasByReplicaUuidTrainingError =
  PostV1ReplicasByReplicaUuidTrainingErrors[keyof PostV1ReplicasByReplicaUuidTrainingErrors]

export type PostV1ReplicasByReplicaUuidTrainingResponses = {
  /**
   * The created knowledge base entry
   */
  200: {
    /**
     * Indicates if the knowledge base entry was created successfully
     */
    success: boolean
    /**
     * The unique identifier for the newly created knowledge base entry. You'll need this ID for subsequent operations like adding content via the Update endpoint.
     */
    knowledgeBaseID: number
  }
}

export type PostV1ReplicasByReplicaUuidTrainingResponse =
  PostV1ReplicasByReplicaUuidTrainingResponses[keyof PostV1ReplicasByReplicaUuidTrainingResponses]

export type PutV1ReplicasByReplicaUuidTrainingByTrainingIdData = {
  body?: {
    /**
     * The text content you want your replica to learn
     */
    rawText?: string
    /**
     * Pre-processed text ready for the knowledge base
     */
    processedText?: string
    /**
     * ID of the vector entry in the database
     */
    vectorEntryId?: string
    /**
     * Additional information about the knowledge base entry (only used with vectorEntryId)
     */
    metadata?: {}
  }
  path: {
    replicaUUID: ReplicaUuidParameter
    /**
     * The ID of the knowledge base entry
     */
    trainingID?: number | null
  }
  query?: never
  url: '/v1/replicas/{replicaUUID}/training/{trainingID}'
}

export type PutV1ReplicasByReplicaUuidTrainingByTrainingIdErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Not Found
   */
  404: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type PutV1ReplicasByReplicaUuidTrainingByTrainingIdError =
  PutV1ReplicasByReplicaUuidTrainingByTrainingIdErrors[keyof PutV1ReplicasByReplicaUuidTrainingByTrainingIdErrors]

export type PutV1ReplicasByReplicaUuidTrainingByTrainingIdResponses = {
  /**
   * Knowledge base entry updated successfully.
   */
  200: {
    /**
     * Indicates the status of the request
     */
    success: boolean
  }
}

export type PutV1ReplicasByReplicaUuidTrainingByTrainingIdResponse =
  PutV1ReplicasByReplicaUuidTrainingByTrainingIdResponses[keyof PutV1ReplicasByReplicaUuidTrainingByTrainingIdResponses]

export type GetV1ReplicasData = {
  body?: never
  headers?: {
    'X-API-Version'?: string
  }
  path?: never
  query?: {
    /**
     * Filters by the owner UUID of the Replicas
     */
    OWNER_ID?: string
    /**
     * Pagination: The page index to return
     */
    page_index?: number
    /**
     * Pagination: The number of items per page
     */
    page_size?: number
    /**
     * Filters by the replica's slug
     */
    slug?: string
    /**
     * Search: by name of Replica, sorted in ascending order
     */
    search?: string
    /**
     * Filters by tags associated to Replicas
     */
    tags?: Array<
      | 'AI'
      | 'Academic'
      | 'Arts'
      | 'Blockchain'
      | 'Business'
      | 'Celebrity'
      | 'Charity'
      | 'Developer'
      | 'Educator'
      | 'Europe'
      | 'Fashion'
      | 'Finance'
      | 'Food'
      | 'Health & Fitness'
      | 'History'
      | 'Italian'
      | 'Kids'
      | 'Language'
      | 'Law'
      | 'Leadership'
      | 'Lifestyle'
      | 'Literature'
      | 'Love'
      | 'Military'
      | 'Modelling'
      | 'Motivation'
      | 'Movies'
      | 'Music'
      | 'North America'
      | 'Philosophy'
      | 'Politics'
      | 'Religion'
      | 'Science'
      | 'Self-Help'
      | 'Sensay'
      | 'Sports'
      | 'Technology'
      | 'Web'
      | 'Wisdom'
      | 'blockchain'
      | 'engage2earn'
      | 'female'
      | 'investment'
      | 'male'
      | 'meme'
      | 'miniapp'
      | 'telegram'
      | 'web3'
    >
    /**
     * Sorts by name or popularity of Replicas in ascending order
     */
    sort?: 'name' | 'popularity'
    /**
     * Filters by integration
     */
    integration?: 'telegram' | 'discord'
  }
  url: '/v1/replicas'
}

export type GetV1ReplicasErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Not Found
   */
  404: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type GetV1ReplicasError = GetV1ReplicasErrors[keyof GetV1ReplicasErrors]

export type GetV1ReplicasResponses = {
  /**
   * List of Replicas
   */
  200: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    type: string
    /**
     * Array of replica items for the current page. Will be an empty array if no items exist.
     */
    items: Array<{
      /**
       * The name of the replica.
       */
      name: string
      /**
       * A short description of your replica's purpose or personality.
       */
      shortDescription: string
      /**
       * The first thing your replica will say when you start a conversation with them.
       */
      greeting: string
      /**
       * The replica type.
       * `individual`: A replica of yourself.
       * `character`: A replica of a character: can be anything you want.
       * `brand`: A replica of a business persona or organization.
       */
      type?: 'individual' | 'character' | 'brand'
      /**
       * The replica owner ID.
       */
      ownerID: string
      /**
       * Visibility of the replica. When set to `true`, only the owner will be able to find the replica and chat with it.
       */
      private?: boolean
      /**
       * Emails of users who can use the replica.
       */
      whitelistEmails?: Array<string>
      /**
       * The slug of the replica. Slugs can be used by API consumers to determine the URLs where replicas can be found.
       */
      slug: string
      /**
       * The tags associated with the replica. Tags help categorize replicas and make them easier to find.
       */
      tags?: Array<string>
      /**
       * The URL of the profile image of the replica. The image will be downloaded, optimized and stored on our servers, so the URL in the response will be different. Supported formats: .jpg, .jpeg, .png, .bmp, .webp, .avif
       */
      profileImage?: string
      /**
       * Suggested questions when starting a conversation.
       */
      suggestedQuestions?: Array<string>
      llm: {
        /**
         * The LLM model of the replica.
         */
        model?:
          | 'gpt-4o'
          | 'claude-3-5-haiku-latest'
          | 'claude-3-7-sonnet-latest'
          | 'grok-2-latest'
          | 'grok-3-beta'
          | 'deepseek-chat'
          | 'o3-mini'
          | 'gpt-4o-mini'
          | 'huggingface-eva'
          | 'huggingface-dolphin-llama'
        /**
         * The memory mode of the replica.
         */
        memoryMode?: 'prompt-caching' | 'rag-search'
        /**
         * Who is your replica? How do you want it to talk, respond and act.
         */
        systemMessage?: string
        /**
         * The replica's tools. Tools enable agents to interact with the world.
         */
        tools?: Array<
          | 'getTokenInfo'
          | 'getUdaoTokenInfo'
          | 'getSensayTokenInfo'
          | 'getTokenInfoMEAI'
          | 'answerToLife'
          | 'toolhouse'
        >
      }
      /**
       * The replica UUID
       */
      uuid: string
      /**
       * The URL of the profile image of the replica. Please use `profileImage` instead.
       * @deprecated
       */
      profile_image: string | null
      /**
       * The description of the replica. Please use `shortDescription` instead.
       * @deprecated
       */
      short_description: string | null
      /**
       * The introduction of the replica. Please use `greeting` instead.
       * @deprecated
       */
      introduction: string | null
      /**
       * The date and time the replica was created.
       */
      created_at: Date | null
      /**
       * The UUID of the owner of the replica. Please migrate to the new User ID system and use `ownerID` instead.
       * @deprecated
       */
      OWNER_ID: string | null
      /**
       * Whether the replica has voice support.
       */
      voice_enabled: boolean
      /**
       * Whether the replica has video support.
       */
      video_enabled: boolean
      /**
       * The total number of chat history items related to this replica, for all users of the organization.
       */
      chat_history_count: number | null
      /**
       * The replica's tone, personality and behaviour, Please use `llm.systemMessage` instead.
       * @deprecated
       */
      system_message: string
      /**
       * The Discord integration of the replica.
       */
      discord_integration: {
        token: string | null
        service_name: string | null
        is_active: boolean | null
      } | null
      /**
       * The Telegram integration of the replica.
       */
      telegram_integration: {
        token: string | null
        service_name: string | null
      } | null
    }>
    /**
     * The total number of replica items available across all pages
     */
    total: number
  }
}

export type GetV1ReplicasResponse = GetV1ReplicasResponses[keyof GetV1ReplicasResponses]

export type PostV1ReplicasData = {
  body?: {
    /**
     * The name of the replica.
     */
    name: string
    /**
     * A short description of your replica's purpose or personality.
     */
    shortDescription: string
    /**
     * The first thing your replica will say when you start a conversation with them.
     */
    greeting: string
    /**
     * The replica type.
     * `individual`: A replica of yourself.
     * `character`: A replica of a character: can be anything you want.
     * `brand`: A replica of a business persona or organization.
     */
    type?: 'individual' | 'character' | 'brand'
    /**
     * The replica owner ID.
     */
    ownerID: string
    /**
     * Visibility of the replica. When set to `true`, only the owner will be able to find the replica and chat with it.
     */
    private?: boolean
    /**
     * Emails of users who can use the replica.
     */
    whitelistEmails?: Array<string>
    /**
     * The slug of the replica. Slugs can be used by API consumers to determine the URLs where replicas can be found.
     */
    slug: string
    /**
     * The tags associated with the replica. Tags help categorize replicas and make them easier to find.
     */
    tags?: Array<string>
    /**
     * The URL of the profile image of the replica. The image will be downloaded, optimized and stored on our servers, so the URL in the response will be different. Supported formats: .jpg, .jpeg, .png, .bmp, .webp, .avif
     */
    profileImage?: string
    /**
     * Suggested questions when starting a conversation.
     */
    suggestedQuestions?: Array<string>
    llm: {
      /**
       * The LLM model of the replica.
       */
      model?:
        | 'gpt-4o'
        | 'claude-3-5-haiku-latest'
        | 'claude-3-7-sonnet-latest'
        | 'grok-2-latest'
        | 'grok-3-beta'
        | 'deepseek-chat'
        | 'o3-mini'
        | 'gpt-4o-mini'
        | 'huggingface-eva'
        | 'huggingface-dolphin-llama'
      /**
       * The memory mode of the replica.
       */
      memoryMode?: 'prompt-caching' | 'rag-search'
      /**
       * Who is your replica? How do you want it to talk, respond and act.
       */
      systemMessage?: string
      /**
       * The replica's tools. Tools enable agents to interact with the world.
       */
      tools?: Array<
        | 'getTokenInfo'
        | 'getUdaoTokenInfo'
        | 'getSensayTokenInfo'
        | 'getTokenInfoMEAI'
        | 'answerToLife'
        | 'toolhouse'
      >
    }
  }
  headers?: {
    'X-API-Version'?: string
  }
  path?: never
  query?: never
  url: '/v1/replicas'
}

export type PostV1ReplicasErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Not Found
   */
  404: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Conflict
   */
  409: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type PostV1ReplicasError = PostV1ReplicasErrors[keyof PostV1ReplicasErrors]

export type PostV1ReplicasResponses = {
  /**
   * The created replica
   */
  201: {
    /**
     * Indicates if the replica was created successfully
     */
    success: boolean
    /**
     * The replica UUID
     */
    uuid: string
  }
}

export type PostV1ReplicasResponse = PostV1ReplicasResponses[keyof PostV1ReplicasResponses]

export type PostV1ApiKeysInvitesByCodeRedeemData = {
  body?: {
    /**
     * The name of the organization you want to create.
     */
    organizationName: string
    /**
     * The name of the point of contact for the API subscription.
     */
    name: string
    /**
     * The email of the point of contact for the API subscription.
     */
    email: string
  }
  path: {
    /**
     * The code of the invite you want to redeem.
     */
    code: string
  }
  query?: never
  url: '/v1/api-keys/invites/{code}/redeem'
}

export type PostV1ApiKeysInvitesByCodeRedeemErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Not Found
   */
  404: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type PostV1ApiKeysInvitesByCodeRedeemError =
  PostV1ApiKeysInvitesByCodeRedeemErrors[keyof PostV1ApiKeysInvitesByCodeRedeemErrors]

export type PostV1ApiKeysInvitesByCodeRedeemResponses = {
  /**
   * Details about the created Organization and API Key.
   */
  200: {
    success: true
    /**
     * The API key you will need to use to authenticate your requests. The key cannot be retrieved again after it is created: keep it safe.
     */
    apiKey: string
    /**
     * The ID of the organization you have just created. You will need this ID to communicate with our team. Keep it safe.
     */
    organizationID: string
    /**
     * The date until which the API subscroption is valid.
     */
    validUntil: string | null
  }
}

export type PostV1ApiKeysInvitesByCodeRedeemResponse =
  PostV1ApiKeysInvitesByCodeRedeemResponses[keyof PostV1ApiKeysInvitesByCodeRedeemResponses]

export type GetV1TrainingData = {
  body?: never
  headers?: {
    'X-API-Version'?: string
  }
  path?: never
  query?: {
    /**
     * Filter knowledge base entries by their processing status. Use this to find entries in specific states like READY or those with errors.
     */
    status?:
      | 'AWAITING_UPLOAD'
      | 'SUPABASE_ONLY'
      | 'PROCESSING'
      | 'READY'
      | 'SYNC_ERROR'
      | 'ERR_FILE_PROCESSING'
      | 'ERR_TEXT_PROCESSING'
      | 'ERR_TEXT_TO_VECTOR'
      | 'BLANK'
    /**
     * Filter knowledge base entries by their content type. Use this to find specific types of training data like text or file uploads.
     */
    type?: 'file_upload' | 'url' | 'training_history' | 'text'
    /**
     * Page number for pagination. Use this to navigate through large result sets.
     */
    page?: string
    /**
     * Maximum number of entries to return per page (up to 100). Use this to control result set size.
     */
    limit?: string
  }
  url: '/v1/training'
}

export type GetV1TrainingErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Not Found
   */
  404: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type GetV1TrainingError = GetV1TrainingErrors[keyof GetV1TrainingErrors]

export type GetV1TrainingResponses = {
  /**
   * List of knowledge base entries returned successfully.
   */
  200: {
    /**
     * Indicates if the list operation was successful
     */
    success: boolean
    /**
     * Array of knowledge base entries matching your query parameters
     */
    items: Array<{
      /**
       * The unique identifier for this knowledge base entry. Use this ID in subsequent API calls to update or delete this entry.
       */
      id: number
      /**
       * The unique identifier of the replica that owns this knowledge base entry. This links the training data to a specific replica.
       */
      replica_uuid: string | null
      /**
       * The category of knowledge base entry, indicating how the content was added and how it should be processed.
       */
      type: 'file_upload' | 'url' | 'training_history' | 'text'
      /**
       * For file_upload entries, the original filename that was uploaded. This helps identify the source of the content.
       */
      filename: string | null
      /**
       * The current stage in the processing pipeline. Use this to track progress and identify any issues with processing.
       */
      status:
        | 'AWAITING_UPLOAD'
        | 'SUPABASE_ONLY'
        | 'PROCESSING'
        | 'READY'
        | 'SYNC_ERROR'
        | 'ERR_FILE_PROCESSING'
        | 'ERR_TEXT_PROCESSING'
        | 'ERR_TEXT_TO_VECTOR'
        | 'BLANK'
      /**
       * The original, unmodified text content that was submitted for training. May be truncated for large entries.
       */
      raw_text: string | null
      /**
       * The optimized version of the text after system processing. This is what gets converted to vectors for retrieval.
       */
      processed_text: string | null
      /**
       * ISO 8601 timestamp when this knowledge base entry was first created.
       */
      created_at: Date
      /**
       * ISO 8601 timestamp when this knowledge base entry was last modified. Use this to track when processing completed.
       */
      updated_at: Date
      /**
       * Optional title for this knowledge base entry. Helps identify the content in listings.
       */
      title: string | null
      /**
       * Optional description providing more details about this knowledge base entry.
       */
      description: string | null
    }>
  }
}

export type GetV1TrainingResponse = GetV1TrainingResponses[keyof GetV1TrainingResponses]

export type DeleteV1TrainingByTrainingIdData = {
  body?: never
  headers?: {
    'X-API-Version'?: string
  }
  path?: {
    /**
     * The unique identifier of the knowledge base entry you want to permanently remove
     */
    trainingID?: number | null
  }
  query?: never
  url: '/v1/training/{trainingID}'
}

export type DeleteV1TrainingByTrainingIdErrors = {
  /**
   * Knowledge base entry not found.
   */
  404: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
}

export type DeleteV1TrainingByTrainingIdError =
  DeleteV1TrainingByTrainingIdErrors[keyof DeleteV1TrainingByTrainingIdErrors]

export type DeleteV1TrainingByTrainingIdResponses = {
  /**
   * The knowledge base entry was deleted successfully.
   */
  200: {
    /**
     * Indicates whether the knowledge base entry and its associated vector embeddings were successfully deleted from the system
     */
    success: boolean
  }
}

export type DeleteV1TrainingByTrainingIdResponse =
  DeleteV1TrainingByTrainingIdResponses[keyof DeleteV1TrainingByTrainingIdResponses]

export type GetV1TrainingByTrainingIdData = {
  body?: never
  headers?: {
    'X-API-Version'?: string
  }
  path?: {
    /**
     * The unique identifier of the knowledge base entry you want to retrieve details for
     */
    trainingID?: number | null
  }
  query?: never
  url: '/v1/training/{trainingID}'
}

export type GetV1TrainingByTrainingIdErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Not Found
   */
  404: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type GetV1TrainingByTrainingIdError =
  GetV1TrainingByTrainingIdErrors[keyof GetV1TrainingByTrainingIdErrors]

export type GetV1TrainingByTrainingIdResponses = {
  /**
   * The knowledge base entry returned successfully.
   */
  200: {
    /**
     * The unique identifier for this knowledge base entry. Use this ID in subsequent API calls to update or delete this entry.
     */
    id: number
    /**
     * The unique identifier of the replica that owns this knowledge base entry. This links the training data to a specific replica.
     */
    replica_uuid: string | null
    /**
     * The category of knowledge base entry, indicating how the content was added and how it should be processed.
     */
    type: 'file_upload' | 'url' | 'training_history' | 'text'
    /**
     * For file_upload entries, the original filename that was uploaded. This helps identify the source of the content.
     */
    filename: string | null
    /**
     * The current stage in the processing pipeline. Use this to track progress and identify any issues with processing.
     */
    status:
      | 'AWAITING_UPLOAD'
      | 'SUPABASE_ONLY'
      | 'PROCESSING'
      | 'READY'
      | 'SYNC_ERROR'
      | 'ERR_FILE_PROCESSING'
      | 'ERR_TEXT_PROCESSING'
      | 'ERR_TEXT_TO_VECTOR'
      | 'BLANK'
    /**
     * The original, unmodified text content that was submitted for training. May be truncated for large entries.
     */
    raw_text: string | null
    /**
     * The optimized version of the text after system processing. This is what gets converted to vectors for retrieval.
     */
    processed_text: string | null
    /**
     * ISO 8601 timestamp when this knowledge base entry was first created.
     */
    created_at: Date
    /**
     * ISO 8601 timestamp when this knowledge base entry was last modified. Use this to track when processing completed.
     */
    updated_at: Date
    /**
     * Optional title for this knowledge base entry. Helps identify the content in listings.
     */
    title: string | null
    /**
     * Optional description providing more details about this knowledge base entry.
     */
    description: string | null
  }
}

export type GetV1TrainingByTrainingIdResponse =
  GetV1TrainingByTrainingIdResponses[keyof GetV1TrainingByTrainingIdResponses]

export type GetV1ReplicasByReplicaUuidChatHistoryData = {
  body?: never
  headers?: {
    'X-API-Version'?: string
  }
  path: {
    replicaUUID: ReplicaUuidParameter
  }
  query?: never
  url: '/v1/replicas/{replicaUUID}/chat/history'
}

export type GetV1ReplicasByReplicaUuidChatHistoryErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * The replica specified could not be found or you do not have access to it
   */
  404: unknown
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type GetV1ReplicasByReplicaUuidChatHistoryError =
  GetV1ReplicasByReplicaUuidChatHistoryErrors[keyof GetV1ReplicasByReplicaUuidChatHistoryErrors]

export type GetV1ReplicasByReplicaUuidChatHistoryResponses = {
  /**
   * List the chat history of the replica by the currently logged in user
   */
  200: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    type: string
    items?: Array<{
      /**
       * The content of the message
       */
      content: string
      /**
       * The date and time the message was created
       */
      created_at: Date
      /**
       * The ID of the message
       */
      id: number
      /**
       * Whether the replica is private
       */
      is_private: boolean
      /**
       * The role of the message
       */
      role: 'user' | 'assistant'
      /**
       * From which platform is message was sent from
       */
      source: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot'
      /**
       * The sources of information used to create the response via RAG (Retrieval-Augmented Generation)
       */
      sources: Array<{
        /**
         * The ID of the source
         */
        id: number
        /**
         * Relevance score of the source
         */
        score: number
        /**
         * If the source has ever been scored or not
         */
        status: 'scored' | 'unscored'
        /**
         * When the source was created
         */
        created_at: Date
        /**
         * The name of the source
         */
        name: string
        /**
         * The actual content retrieved from the source
         */
        content: string
      }>
      /**
       * The UUID of the user
       */
      user_uuid: string
      /**
       * The ID of the message from the LLM. Present when role is assistant. Will be removed in the future.
       * @deprecated
       */
      original_message_id: string | null
    }>
  }
}

export type GetV1ReplicasByReplicaUuidChatHistoryResponse =
  GetV1ReplicasByReplicaUuidChatHistoryResponses[keyof GetV1ReplicasByReplicaUuidChatHistoryResponses]

export type PostV1ReplicasByReplicaUuidChatHistoryData = {
  body?: {
    /**
     * Content of the message
     */
    content: string
    /**
     * The place where the conversation is happening, which informs where the message should be saved in the chat history.
     */
    source?: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot'
    /**
     * Discord information about the message
     */
    discord_data?: {
      /**
       * Channel ID
       */
      channel_id: string
      /**
       * Channel name
       */
      channel_name: string
      /**
       * Author ID
       */
      author_id: string
      /**
       * Author name
       */
      author_name: string
      /**
       * Message ID
       */
      message_id: string
      /**
       * Message creation timestamp
       */
      created_at?: string
      /**
       * Server ID
       */
      server_id?: string
      /**
       * Server name
       */
      server_name?: string
    }
  }
  headers?: {
    'X-API-Version'?: string
  }
  path: {
    replicaUUID: ReplicaUuidParameter
  }
  query?: never
  url: '/v1/replicas/{replicaUUID}/chat/history'
}

export type PostV1ReplicasByReplicaUuidChatHistoryErrors = {
  /**
   * The replica specified could not be found or you do not have access to it
   */
  404: unknown
}

export type PostV1ReplicasByReplicaUuidChatHistoryResponses = {
  /**
   * Saves the chat history of the replica by the currently logged in user.
   */
  200: {
    /**
     * Indicates the status of the request
     */
    success: boolean
  }
}

export type PostV1ReplicasByReplicaUuidChatHistoryResponse =
  PostV1ReplicasByReplicaUuidChatHistoryResponses[keyof PostV1ReplicasByReplicaUuidChatHistoryResponses]

export type GetV1ReplicasByReplicaUuidChatHistoryTelegramData = {
  body?: never
  path: {
    replicaUUID: ReplicaUuidParameter
  }
  query?: never
  url: '/v1/replicas/{replicaUUID}/chat/history/telegram'
}

export type GetV1ReplicasByReplicaUuidChatHistoryTelegramErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * The replica specified could not be found or you do not have access to it
   */
  404: unknown
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type GetV1ReplicasByReplicaUuidChatHistoryTelegramError =
  GetV1ReplicasByReplicaUuidChatHistoryTelegramErrors[keyof GetV1ReplicasByReplicaUuidChatHistoryTelegramErrors]

export type GetV1ReplicasByReplicaUuidChatHistoryTelegramResponses = {
  /**
   * List the chat history of the replica by the currently logged in user
   */
  200: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    type: string
    items?: Array<{
      /**
       * The content of the message
       */
      content: string
      /**
       * The date and time the message was created
       */
      created_at: Date
      /**
       * The ID of the message
       */
      id: number
      /**
       * Whether the replica is private
       */
      is_private: boolean
      /**
       * The role of the message
       */
      role: 'user' | 'assistant'
      /**
       * From which platform is message was sent from
       */
      source: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot'
      /**
       * The sources of information used to create the response via RAG (Retrieval-Augmented Generation)
       */
      sources: Array<{
        /**
         * The ID of the source
         */
        id: number
        /**
         * Relevance score of the source
         */
        score: number
        /**
         * If the source has ever been scored or not
         */
        status: 'scored' | 'unscored'
        /**
         * When the source was created
         */
        created_at: Date
        /**
         * The name of the source
         */
        name: string
        /**
         * The actual content retrieved from the source
         */
        content: string
      }>
      /**
       * The UUID of the user
       */
      user_uuid: string
      /**
       * The ID of the message from the LLM. Present when role is assistant. Will be removed in the future.
       * @deprecated
       */
      original_message_id: string | null
    }>
  }
}

export type GetV1ReplicasByReplicaUuidChatHistoryTelegramResponse =
  GetV1ReplicasByReplicaUuidChatHistoryTelegramResponses[keyof GetV1ReplicasByReplicaUuidChatHistoryTelegramResponses]

export type PostV1ReplicasByReplicaUuidChatHistoryTelegramData = {
  body?: {
    /**
     * Content of the message
     */
    content: string
    /**
     * Telegram information about the message
     */
    telegram_data: {
      /**
       * Type of the chat, can be either `private`, `group`, `supergroup` or `channel`.
       */
      chat_type: string
      /**
       * Unique identifier for this chat.
       */
      chat_id: number
      /**
       * Sender of the message's userID; may be empty for messages sent to channels. For backward compatibility, if the message was sent on behalf of a chat, the field contains a fake sender user in non-channel chats.
       */
      user_id?: number
      /**
       * Sender of the message's username; may be empty for messages sent to channels. For backward compatibility, if the message was sent on behalf of a chat, the field contains a fake sender user in non-channel chats.
       */
      username?: string
      /**
       * Unique message identifier inside this chat. In specific instances (e.g., message containing a video sent to a big chat).
       */
      message_id: number
      /**
       * Unique identifier of a message thread or a forum topic to which the message belongs; for supergroups only.
       */
      message_thread_id?: number
    }
  }
  path: {
    replicaUUID: ReplicaUuidParameter
  }
  query?: never
  url: '/v1/replicas/{replicaUUID}/chat/history/telegram'
}

export type PostV1ReplicasByReplicaUuidChatHistoryTelegramErrors = {
  /**
   * The replica specified could not be found or you do not have access to it
   */
  404: unknown
}

export type PostV1ReplicasByReplicaUuidChatHistoryTelegramResponses = {
  /**
   * Saves the chat history of the replica by the currently logged in user.
   */
  200: {
    /**
     * Indicates the status of the request
     */
    success: boolean
  }
}

export type PostV1ReplicasByReplicaUuidChatHistoryTelegramResponse =
  PostV1ReplicasByReplicaUuidChatHistoryTelegramResponses[keyof PostV1ReplicasByReplicaUuidChatHistoryTelegramResponses]

export type GetV1ReplicasByReplicaUuidChatHistoryDiscordData = {
  body?: never
  path: {
    replicaUUID: ReplicaUuidParameter
  }
  query?: never
  url: '/v1/replicas/{replicaUUID}/chat/history/discord'
}

export type GetV1ReplicasByReplicaUuidChatHistoryDiscordErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * The replica specified could not be found or you do not have access to it
   */
  404: unknown
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type GetV1ReplicasByReplicaUuidChatHistoryDiscordError =
  GetV1ReplicasByReplicaUuidChatHistoryDiscordErrors[keyof GetV1ReplicasByReplicaUuidChatHistoryDiscordErrors]

export type GetV1ReplicasByReplicaUuidChatHistoryDiscordResponses = {
  /**
   * List the chat history of the replica by the currently logged in user
   */
  200: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    type: string
    items?: Array<{
      /**
       * The content of the message
       */
      content: string
      /**
       * The date and time the message was created
       */
      created_at: Date
      /**
       * The ID of the message
       */
      id: number
      /**
       * Whether the replica is private
       */
      is_private: boolean
      /**
       * The role of the message
       */
      role: 'user' | 'assistant'
      /**
       * From which platform is message was sent from
       */
      source: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot'
      /**
       * The sources of information used to create the response via RAG (Retrieval-Augmented Generation)
       */
      sources: Array<{
        /**
         * The ID of the source
         */
        id: number
        /**
         * Relevance score of the source
         */
        score: number
        /**
         * If the source has ever been scored or not
         */
        status: 'scored' | 'unscored'
        /**
         * When the source was created
         */
        created_at: Date
        /**
         * The name of the source
         */
        name: string
        /**
         * The actual content retrieved from the source
         */
        content: string
      }>
      /**
       * The UUID of the user
       */
      user_uuid: string
      /**
       * The ID of the message from the LLM. Present when role is assistant. Will be removed in the future.
       * @deprecated
       */
      original_message_id: string | null
    }>
  }
}

export type GetV1ReplicasByReplicaUuidChatHistoryDiscordResponse =
  GetV1ReplicasByReplicaUuidChatHistoryDiscordResponses[keyof GetV1ReplicasByReplicaUuidChatHistoryDiscordResponses]

export type GetV1ReplicasByReplicaUuidChatHistoryWebData = {
  body?: never
  path: {
    replicaUUID: ReplicaUuidParameter
  }
  query?: never
  url: '/v1/replicas/{replicaUUID}/chat/history/web'
}

export type GetV1ReplicasByReplicaUuidChatHistoryWebErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * The replica specified could not be found or you do not have access to it
   */
  404: unknown
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type GetV1ReplicasByReplicaUuidChatHistoryWebError =
  GetV1ReplicasByReplicaUuidChatHistoryWebErrors[keyof GetV1ReplicasByReplicaUuidChatHistoryWebErrors]

export type GetV1ReplicasByReplicaUuidChatHistoryWebResponses = {
  /**
   * List the chat history of the replica by the currently logged in user
   */
  200: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    type: string
    items?: Array<{
      /**
       * The content of the message
       */
      content: string
      /**
       * The date and time the message was created
       */
      created_at: Date
      /**
       * The ID of the message
       */
      id: number
      /**
       * Whether the replica is private
       */
      is_private: boolean
      /**
       * The role of the message
       */
      role: 'user' | 'assistant'
      /**
       * From which platform is message was sent from
       */
      source: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot'
      /**
       * The sources of information used to create the response via RAG (Retrieval-Augmented Generation)
       */
      sources: Array<{
        /**
         * The ID of the source
         */
        id: number
        /**
         * Relevance score of the source
         */
        score: number
        /**
         * If the source has ever been scored or not
         */
        status: 'scored' | 'unscored'
        /**
         * When the source was created
         */
        created_at: Date
        /**
         * The name of the source
         */
        name: string
        /**
         * The actual content retrieved from the source
         */
        content: string
      }>
      /**
       * The UUID of the user
       */
      user_uuid: string
      /**
       * The ID of the message from the LLM. Present when role is assistant. Will be removed in the future.
       * @deprecated
       */
      original_message_id: string | null
    }>
  }
}

export type GetV1ReplicasByReplicaUuidChatHistoryWebResponse =
  GetV1ReplicasByReplicaUuidChatHistoryWebResponses[keyof GetV1ReplicasByReplicaUuidChatHistoryWebResponses]

export type GetV1ReplicasByReplicaUuidChatHistoryEmbedData = {
  body?: never
  path: {
    replicaUUID: ReplicaUuidParameter
  }
  query?: never
  url: '/v1/replicas/{replicaUUID}/chat/history/embed'
}

export type GetV1ReplicasByReplicaUuidChatHistoryEmbedErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * The replica specified could not be found or you do not have access to it
   */
  404: unknown
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type GetV1ReplicasByReplicaUuidChatHistoryEmbedError =
  GetV1ReplicasByReplicaUuidChatHistoryEmbedErrors[keyof GetV1ReplicasByReplicaUuidChatHistoryEmbedErrors]

export type GetV1ReplicasByReplicaUuidChatHistoryEmbedResponses = {
  /**
   * List the chat history of the replica by the currently logged in user
   */
  200: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    type: string
    items?: Array<{
      /**
       * The content of the message
       */
      content: string
      /**
       * The date and time the message was created
       */
      created_at: Date
      /**
       * The ID of the message
       */
      id: number
      /**
       * Whether the replica is private
       */
      is_private: boolean
      /**
       * The role of the message
       */
      role: 'user' | 'assistant'
      /**
       * From which platform is message was sent from
       */
      source: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot'
      /**
       * The sources of information used to create the response via RAG (Retrieval-Augmented Generation)
       */
      sources: Array<{
        /**
         * The ID of the source
         */
        id: number
        /**
         * Relevance score of the source
         */
        score: number
        /**
         * If the source has ever been scored or not
         */
        status: 'scored' | 'unscored'
        /**
         * When the source was created
         */
        created_at: Date
        /**
         * The name of the source
         */
        name: string
        /**
         * The actual content retrieved from the source
         */
        content: string
      }>
      /**
       * The UUID of the user
       */
      user_uuid: string
      /**
       * The ID of the message from the LLM. Present when role is assistant. Will be removed in the future.
       * @deprecated
       */
      original_message_id: string | null
    }>
  }
}

export type GetV1ReplicasByReplicaUuidChatHistoryEmbedResponse =
  GetV1ReplicasByReplicaUuidChatHistoryEmbedResponses[keyof GetV1ReplicasByReplicaUuidChatHistoryEmbedResponses]

export type PostV1ReplicasByReplicaUuidChatCompletionsData = {
  body?: {
    /**
     * Content of the message must be between 1 and 10000 characters.
     */
    content: string
    /**
     * When set to true, historical messages are not used in the context, and the message is not appended to the conversation history, thus it is excluded from all future chat context.
     */
    skip_chat_history?: boolean
    /**
     * The place where the conversation is happening, which informs where the message should be saved in the chat history.
     */
    source?: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot'
    /**
     * Discord information about the message
     */
    discord_data?: {
      /**
       * Channel ID
       */
      channel_id: string
      /**
       * Channel name
       */
      channel_name: string
      /**
       * Author ID
       */
      author_id: string
      /**
       * Author name
       */
      author_name: string
      /**
       * Message ID
       */
      message_id: string
      /**
       * Message creation timestamp
       */
      created_at?: string
      /**
       * Server ID
       */
      server_id?: string
      /**
       * Server name
       */
      server_name?: string
    }
  }
  headers?: {
    'X-API-Version'?: string
  }
  path: {
    replicaUUID: ReplicaUuidParameter
  }
  query?: never
  url: '/v1/replicas/{replicaUUID}/chat/completions'
}

export type PostV1ReplicasByReplicaUuidChatCompletionsErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Not Found
   */
  404: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type PostV1ReplicasByReplicaUuidChatCompletionsError =
  PostV1ReplicasByReplicaUuidChatCompletionsErrors[keyof PostV1ReplicasByReplicaUuidChatCompletionsErrors]

export type PostV1ReplicasByReplicaUuidChatCompletionsResponses = {
  /**
   * List of chat messages had with a replica by the current user, including the completion
   */
  200: {
    success: boolean
    content: string
  }
}

export type PostV1ReplicasByReplicaUuidChatCompletionsResponse =
  PostV1ReplicasByReplicaUuidChatCompletionsResponses[keyof PostV1ReplicasByReplicaUuidChatCompletionsResponses]

export type PostV1ReplicasByReplicaUuidChatCompletionsTelegramData = {
  body?: {
    /**
     * Content of the message must be between 1 and 10000 characters.
     */
    content: string
    /**
     * When set to true, historical messages are not used in the context, and the message is not appended to the conversation history, thus it is excluded from all future chat context.
     */
    skip_chat_history?: boolean
    /**
     * Telegram information about the message
     */
    telegram_data: {
      /**
       * Type of the chat, can be either `private`, `group`, `supergroup` or `channel`.
       */
      chat_type: string
      /**
       * Unique identifier for this chat.
       */
      chat_id: number
      /**
       * Sender of the message's userID; may be empty for messages sent to channels. For backward compatibility, if the message was sent on behalf of a chat, the field contains a fake sender user in non-channel chats.
       */
      user_id?: number
      /**
       * Sender of the message's username; may be empty for messages sent to channels. For backward compatibility, if the message was sent on behalf of a chat, the field contains a fake sender user in non-channel chats.
       */
      username?: string
      /**
       * Unique message identifier inside this chat. In specific instances (e.g., message containing a video sent to a big chat).
       */
      message_id: number
      /**
       * Unique identifier of a message thread or a forum topic to which the message belongs; for supergroups only.
       */
      message_thread_id?: number
    }
  }
  path: {
    replicaUUID: ReplicaUuidParameter
  }
  query?: never
  url: '/v1/replicas/{replicaUUID}/chat/completions/telegram'
}

export type PostV1ReplicasByReplicaUuidChatCompletionsTelegramErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Not Found
   */
  404: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type PostV1ReplicasByReplicaUuidChatCompletionsTelegramError =
  PostV1ReplicasByReplicaUuidChatCompletionsTelegramErrors[keyof PostV1ReplicasByReplicaUuidChatCompletionsTelegramErrors]

export type PostV1ReplicasByReplicaUuidChatCompletionsTelegramResponses = {
  /**
   * List of chat messages had with a replica by the current user, including the completion
   */
  200: {
    success: boolean
    content: string
  }
}

export type PostV1ReplicasByReplicaUuidChatCompletionsTelegramResponse =
  PostV1ReplicasByReplicaUuidChatCompletionsTelegramResponses[keyof PostV1ReplicasByReplicaUuidChatCompletionsTelegramResponses]

export type PostV1ExperimentalReplicasByReplicaUuidChatCompletionsData = {
  body?: {
    /**
     * A list of messages that make up the conversation context. Only the last message is used for completion.
     */
    messages: Array<{
      /**
       * The role of the message author. Can be "assistant", "developer", "system", "tool", or "user".
       */
      role: 'assistant' | 'developer' | 'system' | 'tool' | 'user'
      /**
       * The content of the message.
       */
      content: string
      /**
       * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
       */
      name?: string
    }>
    /**
     * When set to false, historical messages are not used in the context, and the message is not appended to the conversation history.
     */
    store?: boolean
    /**
     * The place where the conversation is happening, which informs where the message should be saved in the chat history if `store` is true.
     */
    source?: 'discord' | 'embed' | 'web'
    /**
     * Discord information about the message
     */
    discord_data?: {
      /**
       * Channel ID
       */
      channel_id: string
      /**
       * Channel name
       */
      channel_name: string
      /**
       * Author ID
       */
      author_id: string
      /**
       * Author name
       */
      author_name: string
      /**
       * Message ID
       */
      message_id: string
      /**
       * Message creation timestamp
       */
      created_at?: string
      /**
       * Server ID
       */
      server_id?: string
      /**
       * Server name
       */
      server_name?: string
    }
  }
  path: {
    replicaUUID: ReplicaUuidParameter
  }
  query?: never
  url: '/v1/experimental/replicas/{replicaUUID}/chat/completions'
}

export type PostV1ExperimentalReplicasByReplicaUuidChatCompletionsErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Not Found
   */
  404: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type PostV1ExperimentalReplicasByReplicaUuidChatCompletionsError =
  PostV1ExperimentalReplicasByReplicaUuidChatCompletionsErrors[keyof PostV1ExperimentalReplicasByReplicaUuidChatCompletionsErrors]

export type PostV1ExperimentalReplicasByReplicaUuidChatCompletionsResponses = {
  /**
   * The response format for chat completions.
   */
  200: {
    /**
     * A unique identifier for the chat completion.
     */
    id: string
    /**
     * The Unix timestamp (in seconds) of when the chat completion was created.
     */
    created: number
    /**
     * The object type, which is always "chat.completion"
     */
    object: 'chat.completion'
    /**
     * The model used for the chat completion.
     */
    model: string
    /**
     * An array of chat completion choices.
     */
    choices: Array<{
      /**
       * The index of the choice in the array.
       */
      index: number
      /**
       * The message generated by the model.
       */
      message: {
        /**
         * The role of the message author, which is always "assistant" for completions.
         */
        role: 'assistant'
        /**
         * The content of the message.
         */
        content: string
        /**
         * The tool calls generated by the model, such as function calls.
         */
        tool_calls?: Array<unknown>
      }
      /**
       * Log probabilities for token generation if requested.
       */
      logprobs?: unknown
      /**
       * The reason the model stopped generating tokens.
       */
      finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call'
    }>
    /**
     * Usage statistics for the completion request.
     */
    usage: {
      /**
       * Number of tokens in the prompt.
       */
      prompt_tokens: number
      /**
       * Number of tokens in the generated completion.
       */
      completion_tokens: number
      /**
       * Total number of tokens used (prompt + completion).
       */
      total_tokens: number
    }
  }
}

export type PostV1ExperimentalReplicasByReplicaUuidChatCompletionsResponse =
  PostV1ExperimentalReplicasByReplicaUuidChatCompletionsResponses[keyof PostV1ExperimentalReplicasByReplicaUuidChatCompletionsResponses]

export type DeleteV1UsersMeData = {
  body?: never
  headers?: {
    'X-API-Version'?: string
  }
  path?: never
  query?: never
  url: '/v1/users/me'
}

export type DeleteV1UsersMeErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Not Found
   */
  404: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type DeleteV1UsersMeError = DeleteV1UsersMeErrors[keyof DeleteV1UsersMeErrors]

export type DeleteV1UsersMeResponses = {
  /**
   * User deleted successfully
   */
  204: void
}

export type DeleteV1UsersMeResponse = DeleteV1UsersMeResponses[keyof DeleteV1UsersMeResponses]

export type GetV1UsersMeData = {
  body?: never
  headers?: {
    'X-API-Version'?: string
  }
  path?: never
  query?: never
  url: '/v1/users/me'
}

export type GetV1UsersMeResponses = {
  /**
   * User information
   */
  200: {
    /**
     * The name of the user
     */
    name?: string
    /**
     * The email address
     */
    email?: string
    /**
     * The ID of the user
     */
    id: string
    linkedAccounts?: TheLinkedAccountsOfTheUser
  }
}

export type GetV1UsersMeResponse = GetV1UsersMeResponses[keyof GetV1UsersMeResponses]

export type PutV1UsersMeData = {
  body?: {
    /**
     * The name of the user
     */
    name?: string
    /**
     * The email address
     */
    email?: string
    /**
     * The ID of the user
     */
    id: string
    linkedAccounts?: TheLinkedAccountsOfTheUser
  }
  headers?: {
    'X-API-Version'?: string
  }
  path?: never
  query?: never
  url: '/v1/users/me'
}

export type PutV1UsersMeErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Not Found
   */
  404: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Linked account or email already exists or is invalid
   */
  409: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type PutV1UsersMeError = PutV1UsersMeErrors[keyof PutV1UsersMeErrors]

export type PutV1UsersMeResponses = {
  /**
   * The updated User entity
   */
  200: {
    /**
     * The name of the user
     */
    name?: string
    /**
     * The email address
     */
    email?: string
    /**
     * The ID of the user
     */
    id: string
    linkedAccounts?: TheLinkedAccountsOfTheUser
  }
}

export type PutV1UsersMeResponse = PutV1UsersMeResponses[keyof PutV1UsersMeResponses]

export type PostV1UsersData = {
  body?: {
    /**
     * The name of the user
     */
    name?: string
    /**
     * The email address
     */
    email?: string
    /**
     * The ID of the user
     */
    id?: string
    linkedAccounts?: TheLinkedAccountsOfTheUser
  }
  headers?: {
    'X-API-Version'?: string
  }
  path?: never
  query?: never
  url: '/v1/users'
}

export type PostV1UsersErrors = {
  /**
   * User, email, or linked account already exists
   */
  409: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
}

export type PostV1UsersError = PostV1UsersErrors[keyof PostV1UsersErrors]

export type PostV1UsersResponses = {
  /**
   * The created User entity
   */
  200: {
    /**
     * The name of the user
     */
    name?: string
    /**
     * The email address
     */
    email?: string
    /**
     * The ID of the user
     */
    id: string
    linkedAccounts?: TheLinkedAccountsOfTheUser
  }
}

export type PostV1UsersResponse = PostV1UsersResponses[keyof PostV1UsersResponses]

export type GetV1UsersByUserIdData = {
  body?: never
  headers?: {
    'X-API-Version'?: string
  }
  path: {
    /**
     * User ID
     */
    userID: string
  }
  query?: never
  url: '/v1/users/{userID}'
}

export type GetV1UsersByUserIdErrors = {
  /**
   * User not found
   */
  404: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
}

export type GetV1UsersByUserIdError = GetV1UsersByUserIdErrors[keyof GetV1UsersByUserIdErrors]

export type GetV1UsersByUserIdResponses = {
  /**
   * User entity
   */
  200: {
    /**
     * The name of the user
     */
    name?: string
    /**
     * The email address
     */
    email?: string
    /**
     * The ID of the user
     */
    id: string
    linkedAccounts?: TheLinkedAccountsOfTheUser
  }
}

export type GetV1UsersByUserIdResponse =
  GetV1UsersByUserIdResponses[keyof GetV1UsersByUserIdResponses]

export type GetV1ReplicasByReplicaUuidTrainingFilesUploadData = {
  body?: never
  path: {
    replicaUUID: ReplicaUuidParameter
  }
  query: {
    /**
     * The name of the file you want to upload (e.g., document.pdf, report.docx). Files up to 50MB are supported.
     */
    filename: string
  }
  url: '/v1/replicas/{replicaUUID}/training/files/upload'
}

export type GetV1ReplicasByReplicaUuidTrainingFilesUploadErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Not Found
   */
  404: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type GetV1ReplicasByReplicaUuidTrainingFilesUploadError =
  GetV1ReplicasByReplicaUuidTrainingFilesUploadErrors[keyof GetV1ReplicasByReplicaUuidTrainingFilesUploadErrors]

export type GetV1ReplicasByReplicaUuidTrainingFilesUploadResponses = {
  /**
   * The generated signed URL
   */
  200: {
    /**
     * Indicates if the signed URL was generated successfully
     */
    success: boolean
    /**
     * The temporary URL where you should upload your file using a PUT request with Content-Type: application/octet-stream
     */
    signedURL?: string
    /**
     * The unique identifier for the newly created knowledge base entry. Use this to track the processing status of your file.
     */
    knowledgeBaseID?: number
  }
}

export type GetV1ReplicasByReplicaUuidTrainingFilesUploadResponse =
  GetV1ReplicasByReplicaUuidTrainingFilesUploadResponses[keyof GetV1ReplicasByReplicaUuidTrainingFilesUploadResponses]

export type DeleteV1ReplicasByReplicaUuidData = {
  body?: never
  headers?: {
    'X-API-Version'?: string
  }
  path: {
    replicaUUID: ReplicaUuidParameter
  }
  query?: never
  url: '/v1/replicas/{replicaUUID}'
}

export type DeleteV1ReplicasByReplicaUuidErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Not Found
   */
  404: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type DeleteV1ReplicasByReplicaUuidError =
  DeleteV1ReplicasByReplicaUuidErrors[keyof DeleteV1ReplicasByReplicaUuidErrors]

export type DeleteV1ReplicasByReplicaUuidResponses = {
  /**
   * Replica has been deleted
   */
  200: {
    /**
     * Indicates if the replica was deleted successfully
     */
    success: boolean
  }
}

export type DeleteV1ReplicasByReplicaUuidResponse =
  DeleteV1ReplicasByReplicaUuidResponses[keyof DeleteV1ReplicasByReplicaUuidResponses]

export type GetV1ReplicasByReplicaUuidData = {
  body?: never
  headers?: {
    'X-API-Version'?: string
  }
  path: {
    replicaUUID: ReplicaUuidParameter
  }
  query?: never
  url: '/v1/replicas/{replicaUUID}'
}

export type GetV1ReplicasByReplicaUuidErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Not Found
   */
  404: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type GetV1ReplicasByReplicaUuidError =
  GetV1ReplicasByReplicaUuidErrors[keyof GetV1ReplicasByReplicaUuidErrors]

export type GetV1ReplicasByReplicaUuidResponses = {
  /**
   * The requested replica
   */
  200: {
    /**
     * The name of the replica.
     */
    name: string
    /**
     * A short description of your replica's purpose or personality.
     */
    shortDescription: string
    /**
     * The first thing your replica will say when you start a conversation with them.
     */
    greeting: string
    /**
     * The replica type.
     * `individual`: A replica of yourself.
     * `character`: A replica of a character: can be anything you want.
     * `brand`: A replica of a business persona or organization.
     */
    type?: 'individual' | 'character' | 'brand'
    /**
     * The replica owner ID.
     */
    ownerID: string
    /**
     * Visibility of the replica. When set to `true`, only the owner will be able to find the replica and chat with it.
     */
    private?: boolean
    /**
     * Emails of users who can use the replica.
     */
    whitelistEmails?: Array<string>
    /**
     * The slug of the replica. Slugs can be used by API consumers to determine the URLs where replicas can be found.
     */
    slug: string
    /**
     * The tags associated with the replica. Tags help categorize replicas and make them easier to find.
     */
    tags?: Array<string>
    /**
     * The URL of the profile image of the replica. The image will be downloaded, optimized and stored on our servers, so the URL in the response will be different. Supported formats: .jpg, .jpeg, .png, .bmp, .webp, .avif
     */
    profileImage?: string
    /**
     * Suggested questions when starting a conversation.
     */
    suggestedQuestions?: Array<string>
    llm: {
      /**
       * The LLM model of the replica.
       */
      model?:
        | 'gpt-4o'
        | 'claude-3-5-haiku-latest'
        | 'claude-3-7-sonnet-latest'
        | 'grok-2-latest'
        | 'grok-3-beta'
        | 'deepseek-chat'
        | 'o3-mini'
        | 'gpt-4o-mini'
        | 'huggingface-eva'
        | 'huggingface-dolphin-llama'
      /**
       * The memory mode of the replica.
       */
      memoryMode?: 'prompt-caching' | 'rag-search'
      /**
       * Who is your replica? How do you want it to talk, respond and act.
       */
      systemMessage?: string
      /**
       * The replica's tools. Tools enable agents to interact with the world.
       */
      tools?: Array<
        | 'getTokenInfo'
        | 'getUdaoTokenInfo'
        | 'getSensayTokenInfo'
        | 'getTokenInfoMEAI'
        | 'answerToLife'
        | 'toolhouse'
      >
    }
    /**
     * The replica UUID
     */
    uuid: string
  }
}

export type GetV1ReplicasByReplicaUuidResponse =
  GetV1ReplicasByReplicaUuidResponses[keyof GetV1ReplicasByReplicaUuidResponses]

export type PutV1ReplicasByReplicaUuidData = {
  body?: {
    /**
     * The name of the replica.
     */
    name: string
    /**
     * A short description of your replica's purpose or personality.
     */
    shortDescription: string
    /**
     * The first thing your replica will say when you start a conversation with them.
     */
    greeting: string
    /**
     * The replica type.
     * `individual`: A replica of yourself.
     * `character`: A replica of a character: can be anything you want.
     * `brand`: A replica of a business persona or organization.
     */
    type?: 'individual' | 'character' | 'brand'
    /**
     * The replica owner ID.
     */
    ownerID: string
    /**
     * Visibility of the replica. When set to `true`, only the owner will be able to find the replica and chat with it.
     */
    private?: boolean
    /**
     * Emails of users who can use the replica.
     */
    whitelistEmails?: Array<string>
    /**
     * The slug of the replica. Slugs can be used by API consumers to determine the URLs where replicas can be found.
     */
    slug: string
    /**
     * The tags associated with the replica. Tags help categorize replicas and make them easier to find.
     */
    tags?: Array<string>
    /**
     * The URL of the profile image of the replica. The image will be downloaded, optimized and stored on our servers, so the URL in the response will be different. Supported formats: .jpg, .jpeg, .png, .bmp, .webp, .avif
     */
    profileImage?: string
    /**
     * Suggested questions when starting a conversation.
     */
    suggestedQuestions?: Array<string>
    llm: {
      /**
       * The LLM model of the replica.
       */
      model?:
        | 'gpt-4o'
        | 'claude-3-5-haiku-latest'
        | 'claude-3-7-sonnet-latest'
        | 'grok-2-latest'
        | 'grok-3-beta'
        | 'deepseek-chat'
        | 'o3-mini'
        | 'gpt-4o-mini'
        | 'huggingface-eva'
        | 'huggingface-dolphin-llama'
      /**
       * The memory mode of the replica.
       */
      memoryMode?: 'prompt-caching' | 'rag-search'
      /**
       * Who is your replica? How do you want it to talk, respond and act.
       */
      systemMessage?: string
      /**
       * The replica's tools. Tools enable agents to interact with the world.
       */
      tools?: Array<
        | 'getTokenInfo'
        | 'getUdaoTokenInfo'
        | 'getSensayTokenInfo'
        | 'getTokenInfoMEAI'
        | 'answerToLife'
        | 'toolhouse'
      >
    }
  }
  headers?: {
    'X-API-Version'?: string
  }
  path: {
    replicaUUID: ReplicaUuidParameter
  }
  query?: never
  url: '/v1/replicas/{replicaUUID}'
}

export type PutV1ReplicasByReplicaUuidErrors = {
  /**
   * Bad Request
   */
  400: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unauthorized
   */
  401: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Not Found
   */
  404: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Conflict
   */
  409: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Unsupported Media Type
   */
  415: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
  }
  /**
   * Internal Server Error
   */
  500: {
    /**
     * Indicates the status of the request
     */
    success: boolean
    /**
     * A text representation of the error
     */
    error: string
    /**
     * A unique identifier of the event, useful for reporting
     */
    fingerprint?: string
    /**
     * A unique identifier of the request, useful for reporting
     */
    request_id: string
    /**
     * The inner exception
     */
    inner_exception?: {
      name: string
      message: string
      cause?: string
      stack?: string
    }
  }
}

export type PutV1ReplicasByReplicaUuidError =
  PutV1ReplicasByReplicaUuidErrors[keyof PutV1ReplicasByReplicaUuidErrors]

export type PutV1ReplicasByReplicaUuidResponses = {
  /**
   * The request outcome
   */
  200: {
    /**
     * Indicates if the replica was created successfully
     */
    success: boolean
  }
}

export type PutV1ReplicasByReplicaUuidResponse =
  PutV1ReplicasByReplicaUuidResponses[keyof PutV1ReplicasByReplicaUuidResponses]

export type ClientOptions = {
  baseUrl: 'https://api.sensay.io' | (string & {})
}
