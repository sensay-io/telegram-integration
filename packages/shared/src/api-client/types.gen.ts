// This file is auto-generated by @hey-api/openapi-ts

/**
 * The replica unique identifier (UUID)
 */
export type ReplicaUuidParameter = string;

/**
 * The unique identifier of the knowledge base entry
 */
export type TrainingIdParameter = number | null;

export type WebhookRequest = {
    type: string;
    table: string;
    schema: string;
    record: {
        id: string;
        bucket_id: string;
        path_tokens: Array<string>;
        metadata: {
            size: number;
            mimetype: string;
            eTag: string;
        };
    };
    old_record?: unknown;
};

/**
 * The unique identifier of the knowledge base entry
 */
export type KnowledgeBaseIdParameter = number;

export type GetV1ReplicasData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path?: never;
    query?: {
        /**
         * Filters by the owner UUID of the Replicas
         */
        owner_uuid?: string;
        /**
         * The replica owner ID.
         */
        ownerID?: string;
        /**
         * Pagination: The page number to return
         */
        page?: number;
        /**
         * Pagination: The page index to return
         * @deprecated
         */
        page_index?: number;
        /**
         * Pagination: The number of items per page
         */
        page_size?: number;
        /**
         * Filters by the replica's slug
         */
        slug?: string;
        /**
         * Search: by name of Replica, sorted in ascending order
         */
        search?: string;
        /**
         * Filters by tags associated to Replicas
         */
        tags?: Array<'AI' | 'Academic' | 'Arts' | 'Blockchain' | 'Business' | 'Celebrity' | 'Charity' | 'Developer' | 'Educator' | 'Europe' | 'Fashion' | 'Finance' | 'Food' | 'Health & Fitness' | 'History' | 'Italian' | 'Kids' | 'Language' | 'Law' | 'Leadership' | 'Lifestyle' | 'Literature' | 'Love' | 'Military' | 'Modelling' | 'Motivation' | 'Movies' | 'Music' | 'North America' | 'Philosophy' | 'Politics' | 'Religion' | 'Science' | 'Self-Help' | 'Sensay' | 'Sports' | 'Technology' | 'Web' | 'Wisdom' | 'blockchain' | 'engage2earn' | 'female' | 'investment' | 'male' | 'meme' | 'miniapp' | 'telegram' | 'web3'>;
        /**
         * Sorts by name or popularity of Replicas in ascending order
         */
        sort?: 'name' | 'popularity';
        /**
         * Filters by integration
         */
        integration?: 'telegram' | 'discord';
    };
    url: '/v1/replicas';
};

export type GetV1ReplicasErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasError = GetV1ReplicasErrors[keyof GetV1ReplicasErrors];

export type GetV1ReplicasResponses = {
    /**
     * List of Replicas
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        type: string;
        /**
         * Array of replica items for the current page. Will be an empty array if no items exist.
         */
        items: Array<{
            /**
             * The name of the replica.
             */
            name: string;
            /**
             * The purpose of the replica. This field is not used for training the replica.
             */
            purpose?: string;
            /**
             * A short description of your replica. This field is not used for training the replica.
             */
            shortDescription: string;
            /**
             * The first thing your replica will say when you start a conversation with them.
             */
            greeting: string;
            /**
             * The replica type.
             * `individual`: A replica of yourself.
             * `character`: A replica of a character: can be anything you want.
             * `brand`: A replica of a business persona or organization.
             *
             */
            type?: 'individual' | 'character' | 'brand';
            /**
             * The replica owner ID.
             */
            ownerID: string;
            /**
             * Visibility of the replica. When set to `true`, only the owner and users on the allowlist will be able to find the replica and chat with it.
             */
            private?: boolean;
            /**
             * Emails of users who can use the replica when the replica is private.
             */
            whitelistEmails?: Array<string>;
            /**
             * The slug of the replica. Slugs can be used by API consumers to determine the URLs where replicas can be found.
             */
            slug: string;
            /**
             * The tags associated with the replica. Tags help categorize replicas and make them easier to find.
             */
            tags?: Array<string>;
            /**
             * The URL of the profile image of the replica. The image will be downloaded, optimized and stored on our servers, so the URL in the response will be different. Supported formats: .jpg, .jpeg, .png, .bmp, .webp, .avif
             */
            profileImage?: string;
            /**
             * Suggested questions when starting a conversation.
             */
            suggestedQuestions?: Array<string>;
            llm: {
                /**
                 * The LLM model of the replica.
                 */
                model?: 'gpt-4o' | 'claude-3-5-haiku-latest' | 'claude-3-7-sonnet-latest' | 'claude-4-sonnet-20250514' | 'grok-2-latest' | 'grok-3-beta' | 'deepseek-chat' | 'o3-mini' | 'gpt-4o-mini' | 'huggingface-eva' | 'huggingface-dolphin-llama' | 'asi1-mini';
                /**
                 * Deprecated. The system will automatically choose the best approach.
                 * @deprecated
                 */
                memoryMode?: 'prompt-caching' | 'rag-search';
                /**
                 * Who is your replica? How do you want it to talk, respond and act.
                 */
                systemMessage?: string;
                /**
                 * The replica's tools. Tools enable agents to interact with the world. `getTokenInfo`: Allows replica to get token information
                 *
                 */
                tools?: Array<'getTokenInfo' | 'getUdaoTokenInfo' | 'getSensayTokenInfo' | 'getTokenInfoMEAI' | 'answerToLife' | 'toolhouse' | 'brightUnionGetQuoteTool' | 'brightUnionGetCoverablesTool'>;
            };
            /**
             * Text that can be used to generate a voice preview.
             */
            voicePreviewText?: string;
            /**
             * Whether the replica conversations are accessible to customer support
             * @deprecated
             */
            isAccessibleByCustomerSupport?: boolean;
            /**
             * Whether the replica conversations are accessible to customer support
             */
            isEveryConversationAccessibleBySupport?: boolean;
            /**
             * Whether private conversations are enabled for this replica (conversations not accessible to customer support)
             * @deprecated
             */
            isPrivateConversationsEnabled?: boolean;
            /**
             * The replica UUID
             */
            uuid: string;
            /**
             * The distilled knowledge of the replica
             */
            distilledKnowledge?: string;
            /**
             * The URL of the profile image of the replica. Please use `profileImage` instead.
             * @deprecated
             */
            profile_image: string | null;
            /**
             * The description of the replica. Please use `shortDescription` instead.
             * @deprecated
             */
            short_description: string | null;
            /**
             * The introduction of the replica. Please use `greeting` instead.
             * @deprecated
             */
            introduction: string | null;
            /**
             * The date and time the replica was created.
             */
            created_at: Date | null;
            /**
             * The UUID of the owner of the replica. Please migrate to the new User ID system and use `ownerID` instead.
             * @deprecated
             */
            owner_uuid: string | null;
            /**
             * Whether the replica has voice support.
             */
            voice_enabled: boolean;
            /**
             * Whether the replica has video support.
             */
            video_enabled: boolean;
            /**
             * The total number of chat history items related to this replica, for all users of the organization.
             */
            chat_history_count: number | null;
            /**
             * The replica's tone, personality and behaviour, Please use `llm.systemMessage` instead.
             * @deprecated
             */
            system_message: string;
            /**
             * The Discord integration of the replica.
             */
            discord_integration: {
                token: string | null;
                service_name: string | null;
                is_active: boolean | null;
            } | null;
            /**
             * The Telegram integration of the replica.
             */
            telegram_integration: {
                token: string | null;
                service_name: string | null;
            } | null;
            /**
             * The ElevenLabs voice ID associated with this replica.
             */
            elevenLabsID?: string | null;
        }>;
        /**
         * The total number of replica items available across all pages
         */
        total: number;
    };
};

export type GetV1ReplicasResponse = GetV1ReplicasResponses[keyof GetV1ReplicasResponses];

export type PostV1ReplicasData = {
    body?: {
        /**
         * The name of the replica.
         */
        name: string;
        /**
         * The purpose of the replica. This field is not used for training the replica.
         */
        purpose?: string;
        /**
         * A short description of your replica. This field is not used for training the replica.
         */
        shortDescription: string;
        /**
         * The first thing your replica will say when you start a conversation with them.
         */
        greeting: string;
        /**
         * The replica type.
         * `individual`: A replica of yourself.
         * `character`: A replica of a character: can be anything you want.
         * `brand`: A replica of a business persona or organization.
         *
         */
        type?: 'individual' | 'character' | 'brand';
        /**
         * The replica owner ID.
         */
        ownerID: string;
        /**
         * Visibility of the replica. When set to `true`, only the owner and users on the allowlist will be able to find the replica and chat with it.
         */
        private?: boolean;
        /**
         * Emails of users who can use the replica when the replica is private.
         */
        whitelistEmails?: Array<string>;
        /**
         * The slug of the replica. Slugs can be used by API consumers to determine the URLs where replicas can be found.
         */
        slug: string;
        /**
         * The tags associated with the replica. Tags help categorize replicas and make them easier to find.
         */
        tags?: Array<string>;
        /**
         * The URL of the profile image of the replica. The image will be downloaded, optimized and stored on our servers, so the URL in the response will be different. Supported formats: .jpg, .jpeg, .png, .bmp, .webp, .avif
         */
        profileImage?: string;
        /**
         * Suggested questions when starting a conversation.
         */
        suggestedQuestions?: Array<string>;
        llm: {
            /**
             * The LLM model of the replica.
             */
            model?: 'gpt-4o' | 'claude-3-5-haiku-latest' | 'claude-3-7-sonnet-latest' | 'claude-4-sonnet-20250514' | 'grok-2-latest' | 'grok-3-beta' | 'deepseek-chat' | 'o3-mini' | 'gpt-4o-mini' | 'huggingface-eva' | 'huggingface-dolphin-llama' | 'asi1-mini';
            /**
             * Deprecated. The system will automatically choose the best approach.
             * @deprecated
             */
            memoryMode?: 'prompt-caching' | 'rag-search';
            /**
             * Who is your replica? How do you want it to talk, respond and act.
             */
            systemMessage?: string;
            /**
             * The replica's tools. Tools enable agents to interact with the world. `getTokenInfo`: Allows replica to get token information
             *
             */
            tools?: Array<'getTokenInfo' | 'getUdaoTokenInfo' | 'getSensayTokenInfo' | 'getTokenInfoMEAI' | 'answerToLife' | 'toolhouse' | 'brightUnionGetQuoteTool' | 'brightUnionGetCoverablesTool'>;
        };
        /**
         * Text that can be used to generate a voice preview.
         */
        voicePreviewText?: string;
        /**
         * Whether the replica conversations are accessible to customer support
         * @deprecated
         */
        isAccessibleByCustomerSupport?: boolean;
        /**
         * Whether the replica conversations are accessible to customer support
         */
        isEveryConversationAccessibleBySupport?: boolean;
        /**
         * Whether private conversations are enabled for this replica (conversations not accessible to customer support)
         * @deprecated
         */
        isPrivateConversationsEnabled?: boolean;
    };
    headers?: {
        'X-API-Version'?: string;
        /**
         * Content encoding for request body compression. Optional - when used, client is responsible for gzipping and sending binary data.
         */
        'Content-Encoding'?: 'gzip';
    };
    path?: never;
    query?: never;
    url: '/v1/replicas';
};

export type PostV1ReplicasErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Conflict
     */
    409: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type PostV1ReplicasError = PostV1ReplicasErrors[keyof PostV1ReplicasErrors];

export type PostV1ReplicasResponses = {
    /**
     * The created replica
     */
    201: {
        /**
         * Indicates if the replica was created successfully
         */
        success: boolean;
        /**
         * The replica UUID
         */
        uuid: string;
    };
};

export type PostV1ReplicasResponse = PostV1ReplicasResponses[keyof PostV1ReplicasResponses];

export type PostV1ApiKeysInvitesByCodeRedeemData = {
    body?: {
        /**
         * The name of the organization you want to create.
         */
        organizationName: string;
        /**
         * The name of the point of contact for the API subscription.
         */
        name: string;
        /**
         * The email of the point of contact for the API subscription.
         */
        email: string;
    };
    headers?: {
        'X-API-Version'?: string;
        /**
         * Content encoding for request body compression. Optional - when used, client is responsible for gzipping and sending binary data.
         */
        'Content-Encoding'?: 'gzip';
    };
    path: {
        /**
         * The code of the invite you want to redeem.
         */
        code: string;
    };
    query?: never;
    url: '/v1/api-keys/invites/{code}/redeem';
};

export type PostV1ApiKeysInvitesByCodeRedeemErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type PostV1ApiKeysInvitesByCodeRedeemError = PostV1ApiKeysInvitesByCodeRedeemErrors[keyof PostV1ApiKeysInvitesByCodeRedeemErrors];

export type PostV1ApiKeysInvitesByCodeRedeemResponses = {
    /**
     * Details about the created Organization and API Key.
     */
    200: {
        success: true;
        /**
         * The API key you will need to use to authenticate your requests. The key cannot be retrieved again after it is created: keep it safe.
         */
        apiKey: string;
        /**
         * The ID of the organization you have just created. You will need this ID to communicate with our team. Keep it safe.
         */
        organizationID: string;
        /**
         * The date until which the API subscroption is valid.
         */
        validUntil: string | null;
    };
};

export type PostV1ApiKeysInvitesByCodeRedeemResponse = PostV1ApiKeysInvitesByCodeRedeemResponses[keyof PostV1ApiKeysInvitesByCodeRedeemResponses];

export type GetV1ReplicasByReplicaUuidChatHistoryData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/chat/history';
};

export type GetV1ReplicasByReplicaUuidChatHistoryErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * The replica specified could not be found or you do not have access to it
     */
    404: unknown;
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasByReplicaUuidChatHistoryError = GetV1ReplicasByReplicaUuidChatHistoryErrors[keyof GetV1ReplicasByReplicaUuidChatHistoryErrors];

export type GetV1ReplicasByReplicaUuidChatHistoryResponses = {
    /**
     * List the chat history of the replica by the currently logged in user
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        type: string;
        items?: Array<{
            /**
             * The content of the message
             */
            content: string;
            /**
             * The date and time the message was created
             */
            created_at: Date;
            /**
             * The ID of the message
             */
            id: number;
            /**
             * Whether the replica is private
             */
            is_private: boolean;
            /**
             * The role of the message
             */
            role: 'user' | 'assistant';
            /**
             * From which platform is message was sent from
             */
            source: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot';
            /**
             * The sources of information used to create the response via RAG (Retrieval-Augmented Generation)
             */
            sources: Array<{
                /**
                 * The ID of the source
                 */
                id: number;
                /**
                 * Relevance score of the source
                 */
                score: number;
                /**
                 * If the source has ever been scored or not
                 */
                status: 'scored' | 'unscored';
                /**
                 * When the source was created
                 */
                created_at: Date;
                /**
                 * The name of the source
                 */
                name: string;
                /**
                 * The actual content retrieved from the source
                 */
                content: string;
            }>;
            /**
             * The UUID of the user
             */
            user_uuid: string;
            /**
             * The ID of the message from the LLM. Present when role is assistant. Will be removed in the future.
             * @deprecated
             */
            original_message_id: string | null;
        }>;
    };
};

export type GetV1ReplicasByReplicaUuidChatHistoryResponse = GetV1ReplicasByReplicaUuidChatHistoryResponses[keyof GetV1ReplicasByReplicaUuidChatHistoryResponses];

export type PostV1ReplicasByReplicaUuidChatHistoryData = {
    body?: {
        /**
         * Content of the message
         */
        content: string;
        /**
         * The place where the conversation is happening, which informs where the message should be saved in the chat history.
         */
        source?: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot';
        /**
         * Discord information about the message
         */
        discord_data?: {
            /**
             * Channel ID
             */
            channel_id: string;
            /**
             * Channel name
             */
            channel_name: string;
            /**
             * Author ID
             */
            author_id: string;
            /**
             * Author name
             */
            author_name: string;
            /**
             * Message ID
             */
            message_id: string;
            /**
             * Message creation timestamp
             */
            created_at?: string;
            /**
             * Server ID
             */
            server_id?: string;
            /**
             * Server name
             */
            server_name?: string;
        };
    };
    headers?: {
        'X-API-Version'?: string;
        /**
         * Content encoding for request body compression. Optional - when used, client is responsible for gzipping and sending binary data.
         */
        'Content-Encoding'?: 'gzip';
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/chat/history';
};

export type PostV1ReplicasByReplicaUuidChatHistoryErrors = {
    /**
     * The replica specified could not be found or you do not have access to it
     */
    404: unknown;
};

export type PostV1ReplicasByReplicaUuidChatHistoryResponses = {
    /**
     * Saves the chat history of the replica by the currently logged in user.
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
    };
};

export type PostV1ReplicasByReplicaUuidChatHistoryResponse = PostV1ReplicasByReplicaUuidChatHistoryResponses[keyof PostV1ReplicasByReplicaUuidChatHistoryResponses];

export type GetV1ReplicasByReplicaUuidChatHistoryTelegramData = {
    body?: never;
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/chat/history/telegram';
};

export type GetV1ReplicasByReplicaUuidChatHistoryTelegramErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * The replica specified could not be found or you do not have access to it
     */
    404: unknown;
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasByReplicaUuidChatHistoryTelegramError = GetV1ReplicasByReplicaUuidChatHistoryTelegramErrors[keyof GetV1ReplicasByReplicaUuidChatHistoryTelegramErrors];

export type GetV1ReplicasByReplicaUuidChatHistoryTelegramResponses = {
    /**
     * List the chat history of the replica by the currently logged in user
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        type: string;
        items?: Array<{
            /**
             * The content of the message
             */
            content: string;
            /**
             * The date and time the message was created
             */
            created_at: Date;
            /**
             * The ID of the message
             */
            id: number;
            /**
             * Whether the replica is private
             */
            is_private: boolean;
            /**
             * The role of the message
             */
            role: 'user' | 'assistant';
            /**
             * From which platform is message was sent from
             */
            source: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot';
            /**
             * The sources of information used to create the response via RAG (Retrieval-Augmented Generation)
             */
            sources: Array<{
                /**
                 * The ID of the source
                 */
                id: number;
                /**
                 * Relevance score of the source
                 */
                score: number;
                /**
                 * If the source has ever been scored or not
                 */
                status: 'scored' | 'unscored';
                /**
                 * When the source was created
                 */
                created_at: Date;
                /**
                 * The name of the source
                 */
                name: string;
                /**
                 * The actual content retrieved from the source
                 */
                content: string;
            }>;
            /**
             * The UUID of the user
             */
            user_uuid: string;
            /**
             * The ID of the message from the LLM. Present when role is assistant. Will be removed in the future.
             * @deprecated
             */
            original_message_id: string | null;
        }>;
    };
};

export type GetV1ReplicasByReplicaUuidChatHistoryTelegramResponse = GetV1ReplicasByReplicaUuidChatHistoryTelegramResponses[keyof GetV1ReplicasByReplicaUuidChatHistoryTelegramResponses];

export type PostV1ReplicasByReplicaUuidChatHistoryTelegramData = {
    body?: {
        /**
         * Content of the message
         */
        content: string;
        /**
         * Telegram information about the message
         */
        telegram_data: {
            /**
             * Type of the chat, can be either `private`, `group`, `supergroup` or `channel`.
             */
            chat_type: string;
            /**
             * Unique identifier for this chat.
             */
            chat_id: number;
            /**
             * Name of the chat (group name, channel title, or user display name for private chats).
             */
            chat_name?: string;
            /**
             * Sender of the message's userID; may be empty for messages sent to channels. For backward compatibility, if the message was sent on behalf of a chat, the field contains a fake sender user in non-channel chats.
             */
            user_id?: number;
            /**
             * Sender of the message's username; may be empty for messages sent to channels. For backward compatibility, if the message was sent on behalf of a chat, the field contains a fake sender user in non-channel chats.
             */
            username?: string;
            /**
             * Unique message identifier inside this chat. In specific instances (e.g., message containing a video sent to a big chat).
             */
            message_id: number;
            /**
             * Unique identifier of a message thread or a forum topic to which the message belongs; for supergroups only.
             */
            message_thread_id?: number;
        };
    };
    headers?: {
        'X-API-Version'?: string;
        /**
         * Content encoding for request body compression. Optional - when used, client is responsible for gzipping and sending binary data.
         */
        'Content-Encoding'?: 'gzip';
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/chat/history/telegram';
};

export type PostV1ReplicasByReplicaUuidChatHistoryTelegramErrors = {
    /**
     * The replica specified could not be found or you do not have access to it
     */
    404: unknown;
};

export type PostV1ReplicasByReplicaUuidChatHistoryTelegramResponses = {
    /**
     * Saves the chat history of the replica by the currently logged in user.
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
    };
};

export type PostV1ReplicasByReplicaUuidChatHistoryTelegramResponse = PostV1ReplicasByReplicaUuidChatHistoryTelegramResponses[keyof PostV1ReplicasByReplicaUuidChatHistoryTelegramResponses];

export type GetV1ReplicasByReplicaUuidChatHistoryDiscordData = {
    body?: never;
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/chat/history/discord';
};

export type GetV1ReplicasByReplicaUuidChatHistoryDiscordErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * The replica specified could not be found or you do not have access to it
     */
    404: unknown;
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasByReplicaUuidChatHistoryDiscordError = GetV1ReplicasByReplicaUuidChatHistoryDiscordErrors[keyof GetV1ReplicasByReplicaUuidChatHistoryDiscordErrors];

export type GetV1ReplicasByReplicaUuidChatHistoryDiscordResponses = {
    /**
     * List the chat history of the replica by the currently logged in user
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        type: string;
        items?: Array<{
            /**
             * The content of the message
             */
            content: string;
            /**
             * The date and time the message was created
             */
            created_at: Date;
            /**
             * The ID of the message
             */
            id: number;
            /**
             * Whether the replica is private
             */
            is_private: boolean;
            /**
             * The role of the message
             */
            role: 'user' | 'assistant';
            /**
             * From which platform is message was sent from
             */
            source: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot';
            /**
             * The sources of information used to create the response via RAG (Retrieval-Augmented Generation)
             */
            sources: Array<{
                /**
                 * The ID of the source
                 */
                id: number;
                /**
                 * Relevance score of the source
                 */
                score: number;
                /**
                 * If the source has ever been scored or not
                 */
                status: 'scored' | 'unscored';
                /**
                 * When the source was created
                 */
                created_at: Date;
                /**
                 * The name of the source
                 */
                name: string;
                /**
                 * The actual content retrieved from the source
                 */
                content: string;
            }>;
            /**
             * The UUID of the user
             */
            user_uuid: string;
            /**
             * The ID of the message from the LLM. Present when role is assistant. Will be removed in the future.
             * @deprecated
             */
            original_message_id: string | null;
        }>;
    };
};

export type GetV1ReplicasByReplicaUuidChatHistoryDiscordResponse = GetV1ReplicasByReplicaUuidChatHistoryDiscordResponses[keyof GetV1ReplicasByReplicaUuidChatHistoryDiscordResponses];

export type GetV1ReplicasByReplicaUuidChatHistoryWebData = {
    body?: never;
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/chat/history/web';
};

export type GetV1ReplicasByReplicaUuidChatHistoryWebErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * The replica specified could not be found or you do not have access to it
     */
    404: unknown;
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasByReplicaUuidChatHistoryWebError = GetV1ReplicasByReplicaUuidChatHistoryWebErrors[keyof GetV1ReplicasByReplicaUuidChatHistoryWebErrors];

export type GetV1ReplicasByReplicaUuidChatHistoryWebResponses = {
    /**
     * List the chat history of the replica by the currently logged in user
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        type: string;
        items?: Array<{
            /**
             * The content of the message
             */
            content: string;
            /**
             * The date and time the message was created
             */
            created_at: Date;
            /**
             * The ID of the message
             */
            id: number;
            /**
             * Whether the replica is private
             */
            is_private: boolean;
            /**
             * The role of the message
             */
            role: 'user' | 'assistant';
            /**
             * From which platform is message was sent from
             */
            source: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot';
            /**
             * The sources of information used to create the response via RAG (Retrieval-Augmented Generation)
             */
            sources: Array<{
                /**
                 * The ID of the source
                 */
                id: number;
                /**
                 * Relevance score of the source
                 */
                score: number;
                /**
                 * If the source has ever been scored or not
                 */
                status: 'scored' | 'unscored';
                /**
                 * When the source was created
                 */
                created_at: Date;
                /**
                 * The name of the source
                 */
                name: string;
                /**
                 * The actual content retrieved from the source
                 */
                content: string;
            }>;
            /**
             * The UUID of the user
             */
            user_uuid: string;
            /**
             * The ID of the message from the LLM. Present when role is assistant. Will be removed in the future.
             * @deprecated
             */
            original_message_id: string | null;
        }>;
    };
};

export type GetV1ReplicasByReplicaUuidChatHistoryWebResponse = GetV1ReplicasByReplicaUuidChatHistoryWebResponses[keyof GetV1ReplicasByReplicaUuidChatHistoryWebResponses];

export type GetV1ReplicasByReplicaUuidChatHistoryEmbedData = {
    body?: never;
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/chat/history/embed';
};

export type GetV1ReplicasByReplicaUuidChatHistoryEmbedErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * The replica specified could not be found or you do not have access to it
     */
    404: unknown;
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasByReplicaUuidChatHistoryEmbedError = GetV1ReplicasByReplicaUuidChatHistoryEmbedErrors[keyof GetV1ReplicasByReplicaUuidChatHistoryEmbedErrors];

export type GetV1ReplicasByReplicaUuidChatHistoryEmbedResponses = {
    /**
     * List the chat history of the replica by the currently logged in user
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        type: string;
        items?: Array<{
            /**
             * The content of the message
             */
            content: string;
            /**
             * The date and time the message was created
             */
            created_at: Date;
            /**
             * The ID of the message
             */
            id: number;
            /**
             * Whether the replica is private
             */
            is_private: boolean;
            /**
             * The role of the message
             */
            role: 'user' | 'assistant';
            /**
             * From which platform is message was sent from
             */
            source: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot';
            /**
             * The sources of information used to create the response via RAG (Retrieval-Augmented Generation)
             */
            sources: Array<{
                /**
                 * The ID of the source
                 */
                id: number;
                /**
                 * Relevance score of the source
                 */
                score: number;
                /**
                 * If the source has ever been scored or not
                 */
                status: 'scored' | 'unscored';
                /**
                 * When the source was created
                 */
                created_at: Date;
                /**
                 * The name of the source
                 */
                name: string;
                /**
                 * The actual content retrieved from the source
                 */
                content: string;
            }>;
            /**
             * The UUID of the user
             */
            user_uuid: string;
            /**
             * The ID of the message from the LLM. Present when role is assistant. Will be removed in the future.
             * @deprecated
             */
            original_message_id: string | null;
        }>;
    };
};

export type GetV1ReplicasByReplicaUuidChatHistoryEmbedResponse = GetV1ReplicasByReplicaUuidChatHistoryEmbedResponses[keyof GetV1ReplicasByReplicaUuidChatHistoryEmbedResponses];

export type PostV1ReplicasByReplicaUuidChatCompletionsData = {
    body?: {
        /**
         * The prompt to generate completions for, encoded as a string.
         */
        content: string;
        /**
         * When set to true, historical messages are not used in the context, and the message is not appended to the conversation history, thus it is excluded from all future chat context.
         */
        skip_chat_history?: boolean;
        /**
         * The place where the conversation is happening, which informs where the message should be saved in the chat history.
         */
        source?: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot';
        /**
         * Discord information about the message
         */
        discord_data?: {
            /**
             * Channel ID
             */
            channel_id: string;
            /**
             * Channel name
             */
            channel_name: string;
            /**
             * Author ID
             */
            author_id: string;
            /**
             * Author name
             */
            author_name: string;
            /**
             * Message ID
             */
            message_id: string;
            /**
             * Message creation timestamp
             */
            created_at?: string;
            /**
             * Server ID
             */
            server_id?: string;
            /**
             * Server name
             */
            server_name?: string;
        };
    };
    headers?: {
        'X-API-Version'?: string;
        /**
         * Content encoding for request body compression. Optional - when used, client is responsible for gzipping and sending binary data.
         */
        'Content-Encoding'?: 'gzip';
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/chat/completions';
};

export type PostV1ReplicasByReplicaUuidChatCompletionsErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type PostV1ReplicasByReplicaUuidChatCompletionsError = PostV1ReplicasByReplicaUuidChatCompletionsErrors[keyof PostV1ReplicasByReplicaUuidChatCompletionsErrors];

export type PostV1ReplicasByReplicaUuidChatCompletionsResponses = {
    /**
     * List of chat messages had with a replica by the current user, including the completion
     */
    200: {
        success: boolean;
        content: string;
    };
};

export type PostV1ReplicasByReplicaUuidChatCompletionsResponse = PostV1ReplicasByReplicaUuidChatCompletionsResponses[keyof PostV1ReplicasByReplicaUuidChatCompletionsResponses];

export type PostV1ReplicasByReplicaUuidChatCompletionsTelegramData = {
    body?: {
        /**
         * The prompt to generate completions for, encoded as a string.
         */
        content: string;
        /**
         * When set to true, historical messages are not used in the context, and the message is not appended to the conversation history, thus it is excluded from all future chat context.
         */
        skip_chat_history?: boolean;
        /**
         * The URL of the image to be used as context for the completion.
         */
        imageURL?: string;
        /**
         * Telegram information about the message
         */
        telegram_data: {
            /**
             * Type of the chat, can be either `private`, `group`, `supergroup` or `channel`.
             */
            chat_type: string;
            /**
             * Unique identifier for this chat.
             */
            chat_id: number;
            /**
             * Name of the chat (group name, channel title, or user display name for private chats).
             */
            chat_name?: string;
            /**
             * Sender of the message's userID; may be empty for messages sent to channels. For backward compatibility, if the message was sent on behalf of a chat, the field contains a fake sender user in non-channel chats.
             */
            user_id?: number;
            /**
             * Sender of the message's username; may be empty for messages sent to channels. For backward compatibility, if the message was sent on behalf of a chat, the field contains a fake sender user in non-channel chats.
             */
            username?: string;
            /**
             * Unique message identifier inside this chat. In specific instances (e.g., message containing a video sent to a big chat).
             */
            message_id: number;
            /**
             * Unique identifier of a message thread or a forum topic to which the message belongs; for supergroups only.
             */
            message_thread_id?: number;
        };
    };
    headers?: {
        'X-API-Version'?: string;
        /**
         * Content encoding for request body compression. Optional - when used, client is responsible for gzipping and sending binary data.
         */
        'Content-Encoding'?: 'gzip';
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/chat/completions/telegram';
};

export type PostV1ReplicasByReplicaUuidChatCompletionsTelegramErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type PostV1ReplicasByReplicaUuidChatCompletionsTelegramError = PostV1ReplicasByReplicaUuidChatCompletionsTelegramErrors[keyof PostV1ReplicasByReplicaUuidChatCompletionsTelegramErrors];

export type PostV1ReplicasByReplicaUuidChatCompletionsTelegramResponses = {
    /**
     * List of chat messages had with a replica by the current user, including the completion
     */
    200: {
        success: boolean;
        content: string;
    };
};

export type PostV1ReplicasByReplicaUuidChatCompletionsTelegramResponse = PostV1ReplicasByReplicaUuidChatCompletionsTelegramResponses[keyof PostV1ReplicasByReplicaUuidChatCompletionsTelegramResponses];

export type PostV1ExperimentalReplicasByReplicaUuidChatCompletionsData = {
    body?: {
        /**
         * A list of messages that make up the conversation context. Only the last message is used for completion.
         */
        messages: Array<{
            /**
             * The role of the message author. Can be "assistant", "developer", "system", "tool", or "user".
             */
            role: 'assistant' | 'developer' | 'system' | 'tool' | 'user';
            /**
             * The content of the message.
             */
            content: string;
            /**
             * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
             */
            name?: string;
        }>;
        /**
         * When set to false, historical messages are not used in the context, and the message is not appended to the conversation history.
         */
        store?: boolean;
        /**
         * The place where the conversation is happening, which informs where the message should be saved in the chat history if `store` is true.
         */
        source?: 'discord' | 'embed' | 'web';
        /**
         * Discord information about the message
         */
        discord_data?: {
            /**
             * Channel ID
             */
            channel_id: string;
            /**
             * Channel name
             */
            channel_name: string;
            /**
             * Author ID
             */
            author_id: string;
            /**
             * Author name
             */
            author_name: string;
            /**
             * Message ID
             */
            message_id: string;
            /**
             * Message creation timestamp
             */
            created_at?: string;
            /**
             * Server ID
             */
            server_id?: string;
            /**
             * Server name
             */
            server_name?: string;
        };
    };
    headers?: {
        'X-API-Version'?: string;
        /**
         * Content encoding for request body compression. Optional - when used, client is responsible for gzipping and sending binary data.
         */
        'Content-Encoding'?: 'gzip';
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/experimental/replicas/{replicaUUID}/chat/completions';
};

export type PostV1ExperimentalReplicasByReplicaUuidChatCompletionsErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type PostV1ExperimentalReplicasByReplicaUuidChatCompletionsError = PostV1ExperimentalReplicasByReplicaUuidChatCompletionsErrors[keyof PostV1ExperimentalReplicasByReplicaUuidChatCompletionsErrors];

export type PostV1ExperimentalReplicasByReplicaUuidChatCompletionsResponses = {
    /**
     * The response format for chat completions.
     */
    200: {
        /**
         * A unique identifier for the chat completion.
         */
        id: string;
        /**
         * The Unix timestamp (in seconds) of when the chat completion was created.
         */
        created: number;
        /**
         * The object type, which is always "chat.completion"
         */
        object: 'chat.completion';
        /**
         * The model used for the chat completion.
         */
        model: string;
        /**
         * An array of chat completion choices.
         */
        choices: Array<{
            /**
             * The index of the choice in the array.
             */
            index: number;
            /**
             * The message generated by the model.
             */
            message: {
                /**
                 * The role of the message author, which is always "assistant" for completions.
                 */
                role: 'assistant';
                /**
                 * The content of the message.
                 */
                content: string;
                /**
                 * The tool calls generated by the model, such as function calls.
                 */
                tool_calls?: Array<unknown>;
            };
            /**
             * Log probabilities for token generation if requested.
             */
            logprobs?: unknown;
            /**
             * The reason the model stopped generating tokens.
             */
            finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call';
        }>;
        /**
         * Usage statistics for the completion request.
         */
        usage: {
            /**
             * Number of tokens in the prompt.
             */
            prompt_tokens: number;
            /**
             * Number of tokens in the generated completion.
             */
            completion_tokens: number;
            /**
             * Total number of tokens used (prompt + completion).
             */
            total_tokens: number;
        };
    };
};

export type PostV1ExperimentalReplicasByReplicaUuidChatCompletionsResponse = PostV1ExperimentalReplicasByReplicaUuidChatCompletionsResponses[keyof PostV1ExperimentalReplicasByReplicaUuidChatCompletionsResponses];

export type DeleteV1UsersMeData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/users/me';
};

export type DeleteV1UsersMeErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type DeleteV1UsersMeError = DeleteV1UsersMeErrors[keyof DeleteV1UsersMeErrors];

export type DeleteV1UsersMeResponses = {
    /**
     * User deleted successfully
     */
    204: void;
};

export type DeleteV1UsersMeResponse = DeleteV1UsersMeResponses[keyof DeleteV1UsersMeResponses];

export type GetV1UsersMeData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path?: never;
    query?: never;
    url: '/v1/users/me';
};

export type GetV1UsersMeResponses = {
    /**
     * User information
     */
    200: {
        /**
         * The name of the user
         */
        name?: string;
        /**
         * The email address
         */
        email?: string;
        /**
         * The ID of the user
         */
        id: string;
        /**
         * The linked accounts of the user
         */
        linkedAccounts?: Array<{
            /**
             * The account ID
             */
            accountID: string;
            /**
             * The account type
             */
            accountType: 'discord' | 'telegram' | 'embed';
        }>;
    };
};

export type GetV1UsersMeResponse = GetV1UsersMeResponses[keyof GetV1UsersMeResponses];

export type PutV1UsersMeData = {
    body?: {
        /**
         * The name of the user
         */
        name?: string;
        /**
         * The email address
         */
        email?: string;
        /**
         * The ID of the user
         */
        id: string;
        /**
         * The linked accounts of the user
         */
        linkedAccounts?: Array<{
            /**
             * The account ID
             */
            accountID: string;
            /**
             * The account type
             */
            accountType: 'discord' | 'telegram' | 'embed';
        }>;
    };
    headers?: {
        'X-API-Version'?: string;
        /**
         * Content encoding for request body compression. Optional - when used, client is responsible for gzipping and sending binary data.
         */
        'Content-Encoding'?: 'gzip';
    };
    path?: never;
    query?: never;
    url: '/v1/users/me';
};

export type PutV1UsersMeErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Linked account or email already exists or is invalid
     */
    409: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type PutV1UsersMeError = PutV1UsersMeErrors[keyof PutV1UsersMeErrors];

export type PutV1UsersMeResponses = {
    /**
     * The updated User entity
     */
    200: {
        /**
         * The name of the user
         */
        name?: string;
        /**
         * The email address
         */
        email?: string;
        /**
         * The ID of the user
         */
        id: string;
        /**
         * The linked accounts of the user
         */
        linkedAccounts?: Array<{
            /**
             * The account ID
             */
            accountID: string;
            /**
             * The account type
             */
            accountType: 'discord' | 'telegram' | 'embed';
        }>;
    };
};

export type PutV1UsersMeResponse = PutV1UsersMeResponses[keyof PutV1UsersMeResponses];

export type PostV1UsersData = {
    body?: {
        /**
         * The name of the user
         */
        name?: string;
        /**
         * The email address
         */
        email?: string;
        /**
         * The ID of the user
         */
        id?: string;
        /**
         * The linked accounts of the user
         */
        linkedAccounts?: Array<{
            /**
             * The account ID
             */
            accountID: string;
            /**
             * The account type
             */
            accountType: 'discord' | 'telegram' | 'embed';
        }>;
    };
    headers?: {
        'X-API-Version'?: string;
        /**
         * Content encoding for request body compression. Optional - when used, client is responsible for gzipping and sending binary data.
         */
        'Content-Encoding'?: 'gzip';
    };
    path?: never;
    query?: never;
    url: '/v1/users';
};

export type PostV1UsersErrors = {
    /**
     * User, email, or linked account already exists
     */
    409: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
};

export type PostV1UsersError = PostV1UsersErrors[keyof PostV1UsersErrors];

export type PostV1UsersResponses = {
    /**
     * The created User entity
     */
    200: {
        /**
         * The name of the user
         */
        name?: string;
        /**
         * The email address
         */
        email?: string;
        /**
         * The ID of the user
         */
        id: string;
        /**
         * The linked accounts of the user
         */
        linkedAccounts?: Array<{
            /**
             * The account ID
             */
            accountID: string;
            /**
             * The account type
             */
            accountType: 'discord' | 'telegram' | 'embed';
        }>;
    };
};

export type PostV1UsersResponse = PostV1UsersResponses[keyof PostV1UsersResponses];

export type GetV1UsersByUserIdData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path: {
        /**
         * User ID
         */
        userID: string;
    };
    query?: never;
    url: '/v1/users/{userID}';
};

export type GetV1UsersByUserIdErrors = {
    /**
     * User not found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
};

export type GetV1UsersByUserIdError = GetV1UsersByUserIdErrors[keyof GetV1UsersByUserIdErrors];

export type GetV1UsersByUserIdResponses = {
    /**
     * User entity
     */
    200: {
        /**
         * The name of the user
         */
        name?: string;
        /**
         * The email address
         */
        email?: string;
        /**
         * The ID of the user
         */
        id: string;
        /**
         * The linked accounts of the user
         */
        linkedAccounts?: Array<{
            /**
             * The account ID
             */
            accountID: string;
            /**
             * The account type
             */
            accountType: 'discord' | 'telegram' | 'embed';
        }>;
    };
};

export type GetV1UsersByUserIdResponse = GetV1UsersByUserIdResponses[keyof GetV1UsersByUserIdResponses];

export type DeleteV1ReplicasByReplicaUuidIntegrationsTelegramData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/integrations/telegram';
};

export type DeleteV1ReplicasByReplicaUuidIntegrationsTelegramErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type DeleteV1ReplicasByReplicaUuidIntegrationsTelegramError = DeleteV1ReplicasByReplicaUuidIntegrationsTelegramErrors[keyof DeleteV1ReplicasByReplicaUuidIntegrationsTelegramErrors];

export type DeleteV1ReplicasByReplicaUuidIntegrationsTelegramResponses = {
    /**
     * Telegram integration deleted successfully
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
    };
    /**
     * Telegram integration deleted successfully, but failed to notify the external integration server. If you are using the default Sensay Telegram Integration, we will retry stopping the bot asynchronously.
     */
    202: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * The reason why the operation is accepted instead of returning an immediate success.
         */
        message: string;
    };
};

export type DeleteV1ReplicasByReplicaUuidIntegrationsTelegramResponse = DeleteV1ReplicasByReplicaUuidIntegrationsTelegramResponses[keyof DeleteV1ReplicasByReplicaUuidIntegrationsTelegramResponses];

export type PostV1ReplicasByReplicaUuidIntegrationsTelegramData = {
    body?: {
        /**
         * Telegram Bot ID
         */
        telegram_token: string;
        /**
         * Telegram Bot Name
         */
        mention: string;
    };
    headers?: {
        'X-API-Version'?: string;
        /**
         * Content encoding for request body compression. Optional - when used, client is responsible for gzipping and sending binary data.
         */
        'Content-Encoding'?: 'gzip';
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/integrations/telegram';
};

export type PostV1ReplicasByReplicaUuidIntegrationsTelegramErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type PostV1ReplicasByReplicaUuidIntegrationsTelegramError = PostV1ReplicasByReplicaUuidIntegrationsTelegramErrors[keyof PostV1ReplicasByReplicaUuidIntegrationsTelegramErrors];

export type PostV1ReplicasByReplicaUuidIntegrationsTelegramResponses = {
    /**
     * Telegram integration created successfully
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        id: number;
    };
    /**
     * Telegram integration created successfully, but failed to notify the external integration server. If you are using the default Sensay Telegram Integration, we will retry starting the bot asynchronously.
     */
    202: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        id: number;
        /**
         * The reason why the operation is accepted instead of returning an immediate success.
         */
        message: string;
    };
};

export type PostV1ReplicasByReplicaUuidIntegrationsTelegramResponse = PostV1ReplicasByReplicaUuidIntegrationsTelegramResponses[keyof PostV1ReplicasByReplicaUuidIntegrationsTelegramResponses];

export type DeleteV1ReplicasByReplicaUuidData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}';
};

export type DeleteV1ReplicasByReplicaUuidErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type DeleteV1ReplicasByReplicaUuidError = DeleteV1ReplicasByReplicaUuidErrors[keyof DeleteV1ReplicasByReplicaUuidErrors];

export type DeleteV1ReplicasByReplicaUuidResponses = {
    /**
     * Replica has been deleted
     */
    200: {
        /**
         * Indicates if the replica was deleted successfully
         */
        success: boolean;
    };
};

export type DeleteV1ReplicasByReplicaUuidResponse = DeleteV1ReplicasByReplicaUuidResponses[keyof DeleteV1ReplicasByReplicaUuidResponses];

export type GetV1ReplicasByReplicaUuidData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}';
};

export type GetV1ReplicasByReplicaUuidErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasByReplicaUuidError = GetV1ReplicasByReplicaUuidErrors[keyof GetV1ReplicasByReplicaUuidErrors];

export type GetV1ReplicasByReplicaUuidResponses = {
    /**
     * The requested replica
     */
    200: {
        /**
         * The name of the replica.
         */
        name: string;
        /**
         * The purpose of the replica. This field is not used for training the replica.
         */
        purpose?: string;
        /**
         * A short description of your replica. This field is not used for training the replica.
         */
        shortDescription: string;
        /**
         * The first thing your replica will say when you start a conversation with them.
         */
        greeting: string;
        /**
         * The replica type.
         * `individual`: A replica of yourself.
         * `character`: A replica of a character: can be anything you want.
         * `brand`: A replica of a business persona or organization.
         *
         */
        type?: 'individual' | 'character' | 'brand';
        /**
         * The replica owner ID.
         */
        ownerID: string;
        /**
         * Visibility of the replica. When set to `true`, only the owner and users on the allowlist will be able to find the replica and chat with it.
         */
        private?: boolean;
        /**
         * Emails of users who can use the replica when the replica is private.
         */
        whitelistEmails?: Array<string>;
        /**
         * The slug of the replica. Slugs can be used by API consumers to determine the URLs where replicas can be found.
         */
        slug: string;
        /**
         * The tags associated with the replica. Tags help categorize replicas and make them easier to find.
         */
        tags?: Array<string>;
        /**
         * The URL of the profile image of the replica. The image will be downloaded, optimized and stored on our servers, so the URL in the response will be different. Supported formats: .jpg, .jpeg, .png, .bmp, .webp, .avif
         */
        profileImage?: string;
        /**
         * Suggested questions when starting a conversation.
         */
        suggestedQuestions?: Array<string>;
        llm: {
            /**
             * The LLM model of the replica.
             */
            model?: 'gpt-4o' | 'claude-3-5-haiku-latest' | 'claude-3-7-sonnet-latest' | 'claude-4-sonnet-20250514' | 'grok-2-latest' | 'grok-3-beta' | 'deepseek-chat' | 'o3-mini' | 'gpt-4o-mini' | 'huggingface-eva' | 'huggingface-dolphin-llama' | 'asi1-mini';
            /**
             * Deprecated. The system will automatically choose the best approach.
             * @deprecated
             */
            memoryMode?: 'prompt-caching' | 'rag-search';
            /**
             * Who is your replica? How do you want it to talk, respond and act.
             */
            systemMessage?: string;
            /**
             * The replica's tools. Tools enable agents to interact with the world. `getTokenInfo`: Allows replica to get token information
             *
             */
            tools?: Array<'getTokenInfo' | 'getUdaoTokenInfo' | 'getSensayTokenInfo' | 'getTokenInfoMEAI' | 'answerToLife' | 'toolhouse' | 'brightUnionGetQuoteTool' | 'brightUnionGetCoverablesTool'>;
        };
        /**
         * Text that can be used to generate a voice preview.
         */
        voicePreviewText?: string;
        /**
         * Whether the replica conversations are accessible to customer support
         * @deprecated
         */
        isAccessibleByCustomerSupport?: boolean;
        /**
         * Whether the replica conversations are accessible to customer support
         */
        isEveryConversationAccessibleBySupport?: boolean;
        /**
         * Whether private conversations are enabled for this replica (conversations not accessible to customer support)
         * @deprecated
         */
        isPrivateConversationsEnabled?: boolean;
        /**
         * The replica UUID
         */
        uuid: string;
        /**
         * The distilled knowledge of the replica
         */
        distilledKnowledge?: string;
    };
};

export type GetV1ReplicasByReplicaUuidResponse = GetV1ReplicasByReplicaUuidResponses[keyof GetV1ReplicasByReplicaUuidResponses];

export type PutV1ReplicasByReplicaUuidData = {
    body?: {
        /**
         * The name of the replica.
         */
        name: string;
        /**
         * The purpose of the replica. This field is not used for training the replica.
         */
        purpose?: string;
        /**
         * A short description of your replica. This field is not used for training the replica.
         */
        shortDescription: string;
        /**
         * The first thing your replica will say when you start a conversation with them.
         */
        greeting: string;
        /**
         * The replica type.
         * `individual`: A replica of yourself.
         * `character`: A replica of a character: can be anything you want.
         * `brand`: A replica of a business persona or organization.
         *
         */
        type?: 'individual' | 'character' | 'brand';
        /**
         * The replica owner ID.
         */
        ownerID: string;
        /**
         * Visibility of the replica. When set to `true`, only the owner and users on the allowlist will be able to find the replica and chat with it.
         */
        private?: boolean;
        /**
         * Emails of users who can use the replica when the replica is private.
         */
        whitelistEmails?: Array<string>;
        /**
         * The slug of the replica. Slugs can be used by API consumers to determine the URLs where replicas can be found.
         */
        slug: string;
        /**
         * The tags associated with the replica. Tags help categorize replicas and make them easier to find.
         */
        tags?: Array<string>;
        /**
         * The URL of the profile image of the replica. The image will be downloaded, optimized and stored on our servers, so the URL in the response will be different. Supported formats: .jpg, .jpeg, .png, .bmp, .webp, .avif
         */
        profileImage?: string;
        /**
         * Suggested questions when starting a conversation.
         */
        suggestedQuestions?: Array<string>;
        llm: {
            /**
             * The LLM model of the replica.
             */
            model?: 'gpt-4o' | 'claude-3-5-haiku-latest' | 'claude-3-7-sonnet-latest' | 'claude-4-sonnet-20250514' | 'grok-2-latest' | 'grok-3-beta' | 'deepseek-chat' | 'o3-mini' | 'gpt-4o-mini' | 'huggingface-eva' | 'huggingface-dolphin-llama' | 'asi1-mini';
            /**
             * Deprecated. The system will automatically choose the best approach.
             * @deprecated
             */
            memoryMode?: 'prompt-caching' | 'rag-search';
            /**
             * Who is your replica? How do you want it to talk, respond and act.
             */
            systemMessage?: string;
            /**
             * The replica's tools. Tools enable agents to interact with the world. `getTokenInfo`: Allows replica to get token information
             *
             */
            tools?: Array<'getTokenInfo' | 'getUdaoTokenInfo' | 'getSensayTokenInfo' | 'getTokenInfoMEAI' | 'answerToLife' | 'toolhouse' | 'brightUnionGetQuoteTool' | 'brightUnionGetCoverablesTool'>;
        };
        /**
         * Text that can be used to generate a voice preview.
         */
        voicePreviewText?: string;
        /**
         * Whether the replica conversations are accessible to customer support
         * @deprecated
         */
        isAccessibleByCustomerSupport?: boolean;
        /**
         * Whether the replica conversations are accessible to customer support
         */
        isEveryConversationAccessibleBySupport?: boolean;
        /**
         * Whether private conversations are enabled for this replica (conversations not accessible to customer support)
         * @deprecated
         */
        isPrivateConversationsEnabled?: boolean;
    };
    headers?: {
        'X-API-Version'?: string;
        /**
         * Content encoding for request body compression. Optional - when used, client is responsible for gzipping and sending binary data.
         */
        'Content-Encoding'?: 'gzip';
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}';
};

export type PutV1ReplicasByReplicaUuidErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Conflict
     */
    409: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type PutV1ReplicasByReplicaUuidError = PutV1ReplicasByReplicaUuidErrors[keyof PutV1ReplicasByReplicaUuidErrors];

export type PutV1ReplicasByReplicaUuidResponses = {
    /**
     * The request outcome
     */
    200: {
        /**
         * Indicates if the replica was created successfully
         */
        success: boolean;
    };
};

export type PutV1ReplicasByReplicaUuidResponse = PutV1ReplicasByReplicaUuidResponses[keyof PutV1ReplicasByReplicaUuidResponses];

export type GetV1ReplicasByReplicaUuidConversationsByConversationUuidData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
        /**
         * The conversation UUID.
         */
        conversationUUID: string;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/conversations/{conversationUUID}';
};

export type GetV1ReplicasByReplicaUuidConversationsByConversationUuidErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasByReplicaUuidConversationsByConversationUuidError = GetV1ReplicasByReplicaUuidConversationsByConversationUuidErrors[keyof GetV1ReplicasByReplicaUuidConversationsByConversationUuidErrors];

export type GetV1ReplicasByReplicaUuidConversationsByConversationUuidResponses = {
    /**
     * Conversation details
     */
    200: {
        /**
         * The conversation UUID.
         */
        uuid: string;
        /**
         * The source of the conversation.
         */
        source: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot';
        /**
         * The total number of messages in the conversation.
         */
        messageCount: number;
        /**
         * The total number of assistant replies in the conversation.
         */
        replicaReplyCount: number;
        /**
         * The timestamp of the first message in the conversation.
         */
        firstMessageAt?: Date;
        /**
         * The timestamp of the last message in the conversation.
         */
        lastMessageAt?: Date;
        /**
         * The timestamp of the last assistant reply in the conversation.
         */
        lastReplicaReplyAt?: Date;
        /**
         * The name of the conversation. This can be the name of the user or the name of the group.
         */
        conversationName?: string;
        /**
         * The image URL of the conversation. This can be the profile image of the user or the group.
         */
        conversationImageURL?: string;
        /**
         * A summary of the conversation.
         */
        summary: string;
        /**
         * Common questions asked in this conversation.
         */
        commonQuestions: Array<string>;
        /**
         * Common topics discussed in this conversation.
         */
        commonTopics: Array<string>;
        /**
         * The type of conversation.
         */
        conversationType: 'individual' | 'group';
    };
};

export type GetV1ReplicasByReplicaUuidConversationsByConversationUuidResponse = GetV1ReplicasByReplicaUuidConversationsByConversationUuidResponses[keyof GetV1ReplicasByReplicaUuidConversationsByConversationUuidResponses];

export type GetV1ReplicasByReplicaUuidConversationsData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: {
        /**
         * The number of items per page.
         */
        pageSize?: number | null;
        /**
         * The page number.
         */
        page?: number;
        /**
         * Sort criteria.
         */
        sortBy?: 'replicaReplies' | 'firstMessageAt' | 'lastReplicaReplyAt';
        /**
         * The order of the sort.
         */
        sortOrder?: 'asc' | 'desc';
    };
    url: '/v1/replicas/{replicaUUID}/conversations';
};

export type GetV1ReplicasByReplicaUuidConversationsErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasByReplicaUuidConversationsError = GetV1ReplicasByReplicaUuidConversationsErrors[keyof GetV1ReplicasByReplicaUuidConversationsErrors];

export type GetV1ReplicasByReplicaUuidConversationsResponses = {
    /**
     * List of conversations
     */
    200: {
        items: Array<{
            /**
             * The conversation UUID.
             */
            uuid: string;
            /**
             * The source of the conversation.
             */
            source: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot';
            /**
             * The total number of messages in the conversation.
             */
            messageCount: number;
            /**
             * The total number of assistant replies in the conversation.
             */
            replicaReplyCount: number;
            /**
             * The timestamp of the first message in the conversation.
             */
            firstMessageAt?: Date;
            /**
             * The timestamp of the last message in the conversation.
             */
            lastMessageAt?: Date;
            /**
             * The timestamp of the last assistant reply in the conversation.
             */
            lastReplicaReplyAt?: Date;
            /**
             * The name of the conversation. This can be the name of the user or the name of the group.
             */
            conversationName?: string;
            /**
             * The image URL of the conversation. This can be the profile image of the user or the group.
             */
            conversationImageURL?: string;
            /**
             * A summary of the conversation.
             */
            summary: string;
            /**
             * Common questions asked in this conversation.
             */
            commonQuestions: Array<string>;
            /**
             * Common topics discussed in this conversation.
             */
            commonTopics: Array<string>;
            /**
             * The type of conversation.
             */
            conversationType: 'individual' | 'group';
        }>;
        /**
         * The total number of conversations for this replica.
         */
        total: number;
    };
};

export type GetV1ReplicasByReplicaUuidConversationsResponse = GetV1ReplicasByReplicaUuidConversationsResponses[keyof GetV1ReplicasByReplicaUuidConversationsResponses];

export type GetV1ReplicasByReplicaUuidConversationsByConversationUuidMentionsData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
        /**
         * The conversation unique identifier (UUID)
         */
        conversationUUID: string;
    };
    query?: {
        /**
         * The number of items to fetch. A group of messages is counted as 1 item and a placeholder is counted as 1 item.
         */
        limit?: number;
        /**
         * Only returns results after the given message UUID. Excludes given message UUID.
         */
        afterUUID?: string;
        /**
         * Only returns results before the given message UUID. Excludes given message UUID.
         */
        beforeUUID?: string;
        /**
         * The minimum number of messages to include in the placeholder. Placeholders with less than this number of messages will be expanded into messages.
         */
        minimumMessagesInPlaceholder?: number | null;
    };
    url: '/v1/replicas/{replicaUUID}/conversations/{conversationUUID}/mentions';
};

export type GetV1ReplicasByReplicaUuidConversationsByConversationUuidMentionsErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasByReplicaUuidConversationsByConversationUuidMentionsError = GetV1ReplicasByReplicaUuidConversationsByConversationUuidMentionsErrors[keyof GetV1ReplicasByReplicaUuidConversationsByConversationUuidMentionsErrors];

export type GetV1ReplicasByReplicaUuidConversationsByConversationUuidMentionsResponses = {
    /**
     * List of messages/placeholders
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        items: Array<{
            type: 'mention';
            messages: Array<{
                /**
                 * The UUID of the message.
                 */
                uuid: string;
                /**
                 * The date and time the message was created.
                 */
                createdAt: Date;
                /**
                 * The content of the message.
                 */
                content: string;
                /**
                 * The role of the message sender.
                 */
                role: 'user' | 'assistant';
                /**
                 * The name of the message sender, if available.
                 */
                senderName?: string;
                /**
                 * The avatar URL of the message sender, if available.
                 */
                senderProfileImageURL?: string;
                /**
                 * The source of the message.
                 */
                source: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot';
                replicaUUID: ReplicaUuidParameter;
            }>;
        } | {
            type: 'placeholder';
            /**
             * The number of messages collapsed into this placeholder
             */
            count: number;
        }>;
        /**
         * Whether there are more items available beyond the current page
         */
        hasMore: boolean;
    };
};

export type GetV1ReplicasByReplicaUuidConversationsByConversationUuidMentionsResponse = GetV1ReplicasByReplicaUuidConversationsByConversationUuidMentionsResponses[keyof GetV1ReplicasByReplicaUuidConversationsByConversationUuidMentionsResponses];

export type GetV1ReplicasByReplicaUuidConversationsByConversationUuidMessagesData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
        /**
         * The conversation UUID.
         */
        conversationUUID: string;
    };
    query?: {
        /**
         * The number of messages to fetch.
         */
        limit?: number;
        /**
         * Only show messages after given message UUID. Excludes given message UUID.
         */
        afterUUID?: string;
        /**
         * Only show messages before given message UUID. Excludes given message UUID.
         */
        beforeUUID?: string;
    };
    url: '/v1/replicas/{replicaUUID}/conversations/{conversationUUID}/messages';
};

export type GetV1ReplicasByReplicaUuidConversationsByConversationUuidMessagesErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasByReplicaUuidConversationsByConversationUuidMessagesError = GetV1ReplicasByReplicaUuidConversationsByConversationUuidMessagesErrors[keyof GetV1ReplicasByReplicaUuidConversationsByConversationUuidMessagesErrors];

export type GetV1ReplicasByReplicaUuidConversationsByConversationUuidMessagesResponses = {
    /**
     * List of messages in the conversation
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        items: Array<{
            /**
             * The UUID of the message.
             */
            uuid: string;
            /**
             * The date and time the message was created.
             */
            createdAt: Date;
            /**
             * The content of the message.
             */
            content: string;
            /**
             * The role of the message sender.
             */
            role: 'user' | 'assistant';
            /**
             * The name of the message sender, if available.
             */
            senderName?: string;
            /**
             * The avatar URL of the message sender, if available.
             */
            senderProfileImageURL?: string;
            /**
             * The source of the message.
             */
            source: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot';
            replicaUUID: ReplicaUuidParameter;
        }>;
    };
};

export type GetV1ReplicasByReplicaUuidConversationsByConversationUuidMessagesResponse = GetV1ReplicasByReplicaUuidConversationsByConversationUuidMessagesResponses[keyof GetV1ReplicasByReplicaUuidConversationsByConversationUuidMessagesResponses];

export type GetV1ReplicasByReplicaUuidAnalyticsConversationsHistoricalData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/analytics/conversations/historical';
};

export type GetV1ReplicasByReplicaUuidAnalyticsConversationsHistoricalErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasByReplicaUuidAnalyticsConversationsHistoricalError = GetV1ReplicasByReplicaUuidAnalyticsConversationsHistoricalErrors[keyof GetV1ReplicasByReplicaUuidAnalyticsConversationsHistoricalErrors];

export type GetV1ReplicasByReplicaUuidAnalyticsConversationsHistoricalResponses = {
    /**
     * Historical conversation analytics data
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * List of daily cumulative conversation counts for the last 30 days. The cutoff for counting conversations towards a specific day is UTC midnight.
         */
        items: Array<{
            /**
             * The date in YYYY-MM-DD format.
             */
            date: Date;
            /**
             * The cumulative number of conversations up to this date.
             */
            cumulativeConversations: number;
        }>;
    };
};

export type GetV1ReplicasByReplicaUuidAnalyticsConversationsHistoricalResponse = GetV1ReplicasByReplicaUuidAnalyticsConversationsHistoricalResponses[keyof GetV1ReplicasByReplicaUuidAnalyticsConversationsHistoricalResponses];

export type GetV1ReplicasByReplicaUuidAnalyticsConversationsSourcesData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/analytics/conversations/sources';
};

export type GetV1ReplicasByReplicaUuidAnalyticsConversationsSourcesErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasByReplicaUuidAnalyticsConversationsSourcesError = GetV1ReplicasByReplicaUuidAnalyticsConversationsSourcesErrors[keyof GetV1ReplicasByReplicaUuidAnalyticsConversationsSourcesErrors];

export type GetV1ReplicasByReplicaUuidAnalyticsConversationsSourcesResponses = {
    /**
     * Source analytics data
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * List of conversation counts by source for the replica, as of today.
         */
        items: Array<{
            /**
             * The source of the conversations.
             */
            source: 'discord' | 'telegram' | 'embed' | 'web' | 'telegram_autopilot';
            /**
             * The total number of conversations from this source.
             */
            conversations: number;
        }>;
    };
};

export type GetV1ReplicasByReplicaUuidAnalyticsConversationsSourcesResponse = GetV1ReplicasByReplicaUuidAnalyticsConversationsSourcesResponses[keyof GetV1ReplicasByReplicaUuidAnalyticsConversationsSourcesResponses];

export type PostV1ReplicasByReplicaUuidTrainingData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
        /**
         * Content encoding for request body compression. Optional - when used, client is responsible for gzipping and sending binary data.
         */
        'Content-Encoding'?: 'gzip';
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/training';
};

export type PostV1ReplicasByReplicaUuidTrainingErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type PostV1ReplicasByReplicaUuidTrainingError = PostV1ReplicasByReplicaUuidTrainingErrors[keyof PostV1ReplicasByReplicaUuidTrainingErrors];

export type PostV1ReplicasByReplicaUuidTrainingResponses = {
    /**
     * The created knowledge base entry
     */
    200: {
        /**
         * Indicates if the knowledge base entry was created successfully
         */
        success: boolean;
        /**
         * The unique identifier for the newly created knowledge base entry.
         */
        knowledgeBaseID: number;
    };
};

export type PostV1ReplicasByReplicaUuidTrainingResponse = PostV1ReplicasByReplicaUuidTrainingResponses[keyof PostV1ReplicasByReplicaUuidTrainingResponses];

export type PutV1ReplicasByReplicaUuidTrainingByTrainingIdData = {
    body?: {
        /**
         * The text content you want your replica to learn
         */
        rawText?: string;
        /**
         * Pre-processed text that is ready to be added to the knowledge base. This is typically used when you have already optimized the text format.
         */
        processedText?: string;
        /**
         * The ID of the vector entry in the database. Its presenceindicates the information has been fully processed and is ready for retrieval.
         */
        vectorEntryId?: string;
        /**
         * Additional information about the knowledge base entry, such as source, tags, or other contextual data (only used when vectorEntryId is present)
         */
        metadata?: {};
    };
    headers?: {
        'X-API-Version'?: string;
        /**
         * Content encoding for request body compression. Optional - when used, client is responsible for gzipping and sending binary data.
         */
        'Content-Encoding'?: 'gzip';
    };
    path: {
        replicaUUID: ReplicaUuidParameter;
        trainingID: TrainingIdParameter;
    };
    query?: never;
    url: '/v1/replicas/{replicaUUID}/training/{trainingID}';
};

export type PutV1ReplicasByReplicaUuidTrainingByTrainingIdErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type PutV1ReplicasByReplicaUuidTrainingByTrainingIdError = PutV1ReplicasByReplicaUuidTrainingByTrainingIdErrors[keyof PutV1ReplicasByReplicaUuidTrainingByTrainingIdErrors];

export type PutV1ReplicasByReplicaUuidTrainingByTrainingIdResponses = {
    /**
     * Knowledge base entry updated successfully.
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
    };
};

export type PutV1ReplicasByReplicaUuidTrainingByTrainingIdResponse = PutV1ReplicasByReplicaUuidTrainingByTrainingIdResponses[keyof PutV1ReplicasByReplicaUuidTrainingByTrainingIdResponses];

export type DeleteV1TrainingByTrainingIdData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path: {
        trainingID: TrainingIdParameter;
    };
    query?: never;
    url: '/v1/training/{trainingID}';
};

export type DeleteV1TrainingByTrainingIdErrors = {
    /**
     * Knowledge base entry not found.
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
};

export type DeleteV1TrainingByTrainingIdError = DeleteV1TrainingByTrainingIdErrors[keyof DeleteV1TrainingByTrainingIdErrors];

export type DeleteV1TrainingByTrainingIdResponses = {
    /**
     * The knowledge base entry was deleted successfully.
     */
    200: {
        /**
         * Indicates whether the knowledge base entry and its associated vector embeddings were successfully deleted from the system
         */
        success: boolean;
    };
};

export type DeleteV1TrainingByTrainingIdResponse = DeleteV1TrainingByTrainingIdResponses[keyof DeleteV1TrainingByTrainingIdResponses];

export type GetV1TrainingByTrainingIdData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path: {
        trainingID: TrainingIdParameter;
    };
    query?: never;
    url: '/v1/training/{trainingID}';
};

export type GetV1TrainingByTrainingIdErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1TrainingByTrainingIdError = GetV1TrainingByTrainingIdErrors[keyof GetV1TrainingByTrainingIdErrors];

export type GetV1TrainingByTrainingIdResponses = {
    /**
     * The knowledge base entry returned successfully.
     */
    200: {
        /**
         * The unique identifier for this knowledge base entry. Use this ID in subsequent API calls to update or delete this entry.
         */
        id: number;
        /**
         * The unique identifier of the replica that owns this knowledge base entry. This links the training data to a specific replica.
         */
        replica_uuid: string | null;
        /**
         * The type of knowledge base entry, indicating how the content was added and how it should be processed.
         */
        type: 'file_upload' | 'url' | 'training_history' | 'text';
        /**
         * For file_upload entries, the original filename that was uploaded. This helps identify the source of the content.
         */
        filename: string | null;
        /**
         * For url entries, the original url of the content.
         */
        url?: string;
        /**
         * The current stage in the processing pipeline. Use this to track progress and identify any issues with processing.
         */
        status: 'AWAITING_UPLOAD' | 'SUPABASE_ONLY' | 'PROCESSING' | 'READY' | 'SYNC_ERROR' | 'ERR_FILE_PROCESSING' | 'ERR_TEXT_PROCESSING' | 'ERR_TEXT_TO_VECTOR' | 'BLANK';
        /**
         * The original, unmodified text content that was submitted for training. May be truncated for large entries.
         */
        raw_text: string | null;
        /**
         * The optimized version of the text after system processing. This is what gets converted to vectors for retrieval.
         */
        processed_text: string | null;
        /**
         * ISO 8601 timestamp when this knowledge base entry was first created.
         */
        created_at: Date;
        /**
         * ISO 8601 timestamp when this knowledge base entry was last modified. Use this to track when processing completed.
         */
        updated_at: Date;
        /**
         * Title for this knowledge base entry. Helps identify the content in listings.
         */
        title: string | null;
        /**
         * Optional description providing more details about this knowledge base entry.
         */
        description: string | null;
    };
};

export type GetV1TrainingByTrainingIdResponse = GetV1TrainingByTrainingIdResponses[keyof GetV1TrainingByTrainingIdResponses];

export type GetV1TrainingData = {
    body?: never;
    headers?: {
        'X-API-Version'?: string;
    };
    path?: never;
    query?: {
        /**
         * Filter knowledge base entries by their processing status. Use this to find entries in specific states like READY or those with errors.
         */
        status?: 'AWAITING_UPLOAD' | 'SUPABASE_ONLY' | 'PROCESSING' | 'READY' | 'SYNC_ERROR' | 'ERR_FILE_PROCESSING' | 'ERR_TEXT_PROCESSING' | 'ERR_TEXT_TO_VECTOR' | 'BLANK';
        /**
         * Filter knowledge base entries by their content type. Use this to find specific types of training data like text or file uploads.
         */
        type?: 'file_upload' | 'url' | 'training_history' | 'text';
        /**
         * Page number for pagination. Use this to navigate through large result sets.
         */
        page?: string;
        /**
         * Maximum number of entries to return per page (up to 100). Use this to control result set size.
         */
        limit?: string;
    };
    url: '/v1/training';
};

export type GetV1TrainingErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1TrainingError = GetV1TrainingErrors[keyof GetV1TrainingErrors];

export type GetV1TrainingResponses = {
    /**
     * List of knowledge base entries returned successfully.
     */
    200: {
        /**
         * Indicates if the list operation was successful
         */
        success: boolean;
        /**
         * Array of knowledge base entries matching your query parameters
         */
        items: Array<{
            /**
             * The unique identifier for this knowledge base entry. Use this ID in subsequent API calls to update or delete this entry.
             */
            id: number;
            /**
             * The unique identifier of the replica that owns this knowledge base entry. This links the training data to a specific replica.
             */
            replica_uuid: string | null;
            /**
             * The type of knowledge base entry, indicating how the content was added and how it should be processed.
             */
            type: 'file_upload' | 'url' | 'training_history' | 'text';
            /**
             * For file_upload entries, the original filename that was uploaded. This helps identify the source of the content.
             */
            filename: string | null;
            /**
             * For url entries, the original url of the content.
             */
            url?: string;
            /**
             * The current stage in the processing pipeline. Use this to track progress and identify any issues with processing.
             */
            status: 'AWAITING_UPLOAD' | 'SUPABASE_ONLY' | 'PROCESSING' | 'READY' | 'SYNC_ERROR' | 'ERR_FILE_PROCESSING' | 'ERR_TEXT_PROCESSING' | 'ERR_TEXT_TO_VECTOR' | 'BLANK';
            /**
             * The original, unmodified text content that was submitted for training. May be truncated for large entries.
             */
            raw_text: string | null;
            /**
             * The optimized version of the text after system processing. This is what gets converted to vectors for retrieval.
             */
            processed_text: string | null;
            /**
             * ISO 8601 timestamp when this knowledge base entry was first created.
             */
            created_at: Date;
            /**
             * ISO 8601 timestamp when this knowledge base entry was last modified. Use this to track when processing completed.
             */
            updated_at: Date;
            /**
             * Title for this knowledge base entry. Helps identify the content in listings.
             */
            title: string | null;
            /**
             * Optional description providing more details about this knowledge base entry.
             */
            description: string | null;
        }>;
    };
};

export type GetV1TrainingResponse = GetV1TrainingResponses[keyof GetV1TrainingResponses];

export type GetV1ReplicasByReplicaUuidTrainingFilesUploadData = {
    body?: never;
    path: {
        replicaUUID: ReplicaUuidParameter;
    };
    query: {
        /**
         * The name of the file you want to upload to the knowledge base. This helps identify the file in your knowledge base. Files up to 50MB are supported.
         */
        filename: string;
    };
    url: '/v1/replicas/{replicaUUID}/training/files/upload';
};

export type GetV1ReplicasByReplicaUuidTrainingFilesUploadErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1ReplicasByReplicaUuidTrainingFilesUploadError = GetV1ReplicasByReplicaUuidTrainingFilesUploadErrors[keyof GetV1ReplicasByReplicaUuidTrainingFilesUploadErrors];

export type GetV1ReplicasByReplicaUuidTrainingFilesUploadResponses = {
    /**
     * The generated signed URL
     */
    200: {
        /**
         * Indicates if the signed URL was generated successfully
         */
        success: boolean;
        /**
         * The temporary URL where you should upload your file using a PUT request with Content-Type: application/octet-stream
         */
        signedURL?: string;
        /**
         * The unique identifier for the newly created knowledge base entry. Use this to track the processing status of your file.
         */
        knowledgeBaseID?: number;
    };
};

export type GetV1ReplicasByReplicaUuidTrainingFilesUploadResponse = GetV1ReplicasByReplicaUuidTrainingFilesUploadResponses[keyof GetV1ReplicasByReplicaUuidTrainingFilesUploadResponses];

export type GetV1DebugInfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/debug/info';
};

export type GetV1DebugInfoErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1DebugInfoError = GetV1DebugInfoErrors[keyof GetV1DebugInfoErrors];

export type GetV1DebugInfoResponses = {
    /**
     * Information about the server
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * The type of response
         */
        type: string;
        /**
         * The name of the environment
         */
        environment: string;
        /**
         * The Vercel deployment ID
         */
        deploymentId?: string;
        /**
         * The API version as specified in the version header
         */
        apiVersion?: string;
        /**
         * Whether Sentry connection string is specified
         */
        sentry: boolean;
        /**
         * The Sentry traces sample rate
         */
        sentry_samplerate?: number;
        /**
         * The authentication context for the current session
         */
        auth: {
            [key: string]: unknown;
        };
    };
};

export type GetV1DebugInfoResponse = GetV1DebugInfoResponses[keyof GetV1DebugInfoResponses];

export type GetV1DebugExceptionData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/debug/exception';
};

export type GetV1DebugExceptionErrors = {
    /**
     * A simulated internal server error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
};

export type GetV1DebugExceptionError = GetV1DebugExceptionErrors[keyof GetV1DebugExceptionErrors];

export type GetV1DebugValidationParamByUuidData = {
    body?: never;
    path: {
        /**
         * Test UUID parameter
         */
        UUID: string | null;
    };
    query?: never;
    url: '/v1/debug/validation/param/{UUID}';
};

export type GetV1DebugValidationParamByUuidErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1DebugValidationParamByUuidError = GetV1DebugValidationParamByUuidErrors[keyof GetV1DebugValidationParamByUuidErrors];

export type GetV1DebugValidationParamByUuidResponses = {
    /**
     * Test response
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        type: string;
    };
};

export type GetV1DebugValidationParamByUuidResponse = GetV1DebugValidationParamByUuidResponses[keyof GetV1DebugValidationParamByUuidResponses];

export type GetV1DebugValidationQueryData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Test UUID parameter
         */
        UUID?: string | null;
    };
    url: '/v1/debug/validation/query';
};

export type GetV1DebugValidationQueryErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type GetV1DebugValidationQueryError = GetV1DebugValidationQueryErrors[keyof GetV1DebugValidationQueryErrors];

export type GetV1DebugValidationQueryResponses = {
    /**
     * Test response
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        type: string;
    };
};

export type GetV1DebugValidationQueryResponse = GetV1DebugValidationQueryResponses[keyof GetV1DebugValidationQueryResponses];

export type PostV1DebugValidationJsonData = {
    body?: {
        /**
         * Test UUID parameter
         */
        UUID: string | null;
    };
    headers?: {
        'X-API-Version'?: string;
        /**
         * Content encoding for request body compression. Optional - when used, client is responsible for gzipping and sending binary data.
         */
        'Content-Encoding'?: 'gzip';
    };
    path?: never;
    query?: never;
    url: '/v1/debug/validation/json';
};

export type PostV1DebugValidationJsonErrors = {
    /**
     * Bad Request
     */
    400: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unauthorized
     */
    401: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Not Found
     */
    404: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Unsupported Media Type
     */
    415: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
    /**
     * Internal Server Error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
        /**
         * The inner exception
         */
        inner_exception?: {
            name: string;
            message: string;
            cause?: string;
            stack?: string;
        };
    };
};

export type PostV1DebugValidationJsonError = PostV1DebugValidationJsonErrors[keyof PostV1DebugValidationJsonErrors];

export type PostV1DebugValidationJsonResponses = {
    /**
     * Test response
     */
    200: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        type: string;
    };
};

export type PostV1DebugValidationJsonResponse = PostV1DebugValidationJsonResponses[keyof PostV1DebugValidationJsonResponses];

export type GetV1DebugFetchExceptionData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/debug/fetch-exception';
};

export type GetV1DebugFetchExceptionErrors = {
    /**
     * A simulated fetch error
     */
    500: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
};

export type GetV1DebugFetchExceptionError = GetV1DebugFetchExceptionErrors[keyof GetV1DebugFetchExceptionErrors];

export type GetV1DebugApiErrorData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/v1/debug/api-error';
};

export type GetV1DebugApiErrorErrors = {
    /**
     * A simulated API error
     */
    501: {
        /**
         * Indicates the status of the request
         */
        success: boolean;
        /**
         * A text representation of the error
         */
        error: string;
        /**
         * A unique identifier of the event, useful for reporting
         */
        fingerprint?: string;
        /**
         * A unique identifier of the request, useful for reporting
         */
        request_id: string;
    };
};

export type GetV1DebugApiErrorError = GetV1DebugApiErrorErrors[keyof GetV1DebugApiErrorErrors];

export type PostV1DebugIngestFileData = {
    body?: {
        replica_uuid: string;
        id: string;
        name: string;
        path: string;
    };
    headers?: {
        'X-API-Version'?: string;
        /**
         * Content encoding for request body compression. Optional - when used, client is responsible for gzipping and sending binary data.
         */
        'Content-Encoding'?: 'gzip';
    };
    path?: never;
    query?: never;
    url: '/v1/debug/ingest-file';
};

export type PostV1DebugIngestFileResponses = {
    /**
     * Message sent successfully
     */
    200: {
        success: boolean;
        message: string;
    };
};

export type PostV1DebugIngestFileResponse = PostV1DebugIngestFileResponses[keyof PostV1DebugIngestFileResponses];

export type ClientOptions = {
    baseUrl: 'https://api-9whuf7iwg-sensay.vercel.app' | (string & {});
};